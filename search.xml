<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BugËÆ∞ÂΩï‰πãÂÆâÂçì.9Âõæ]]></title>
    <url>%2F2018%2F06%2F19%2FBug%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%AE%89%E5%8D%93-9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[ÈóÆÈ¢òÁé∞Ë±°PopwindowÈáåÈù¢ÂÜô‰∫Ü‰∏Ä‰∏™ListViewÔºåÊúâ‰∏™Âä†‰∫ÜÂúÜËßíÈò¥ÂΩ±.9ËÉåÊôØÂõæÁöÑLinearLayoutÂÅöÁà∂ÂÆπÂô®„ÄÇListViewÂÜÖÂÆπÂè™ÊòæÁ§∫‰∏Ä‰∏§‰∏™ÁöÑÊó∂ÂÄôÔºåÊ≤°ÊúâË¶ÜÁõñLinearLayoutÔºåÊµÅ‰∫Ü‰∏ÄÈÉ®ÂàÜÁ©∫ÁôΩ„ÄÇ ÂàÜÊûêÈóÆÈ¢òÂàöÂºÄÂßã‰ª•‰∏∫‰ª•‰∏∫ÊòØÂõ†‰∏∫Ëá™Â∑±ÊâãÂä®ËÆæÁΩÆ‰∫ÜListViewÁöÑlayoutparamsÁöÑheightÂÄºÂØºËá¥ÁöÑÔºàÂõ†‰∏∫Ë¶ÅÂÅö‰∏Ä‰∏™ListViewÊúÄÂ§öÊòæÁ§∫5‰∏™ÁöÑÈúÄÊ±ÇÔºâÔºåÂêéÊù•ÂéªÊéâ‰∫ÜËøôÊÆµ‰ª£Á†Å‰æùÁÑ∂Ê≤°ÊúâËß£ÂÜ≥„ÄÇÊúÄÁªàÂÅ∂ÁÑ∂ÂéªÊéâ‰∫ÜLinearLayoutÁöÑ.9ËÉåÊôØÔºåÂèëÁé∞ÊòæÁ§∫ÁöÑÊ≤°ÊúâÈóÆÈ¢ò‰∫ÜÔºåÂéüÊù•ÊòØÂú®ËÆæÁΩÆ‰∫Ü.9ÁöÑÊéß‰ª∂ÔºåÈ´òÂ∫¶‰∏∫Wrap ContentÁöÑÊó∂ÂÄôÔºåLinearLayoutÁöÑÈ´òÂ∫¶‰ª•.9ËÉåÊôØÂõæÁöÑÂéüÂßã‰∏çÂéãÁº©È´òÂ∫¶Êù•ËÆ°ÁÆóÔºåÂπ∂‰∏ç‰ºöÂéãÁº©üòÖ]]></content>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio .gitignore‰øÆÊîπÂêé‰∏çÁîüÊïàÁöÑÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F06%2F01%2FAndroid-Studio-gitignore%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ÈóÆÈ¢òAndroid Studio .gitignore‰øÆÊîπÂêé‰∏çÁîüÊïàÔºåÊ≤°ÊúâignoreÂØπÂ∫îÁöÑÊñá‰ª∂Ôºå ÂéüÂõ†gitÊ≤°ÊúâÊ∏ÖÁêÜcacheÈáçÁÇπÂÜÖÂÆπ Ëß£ÂÜ≥ÊñπÊ°à123git rm -r --cached .git add .git commit -m &apos;Your commit-msg&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AndroidÂºÄÂèëËÄÖÈáçË£ÖUbuntuÈúÄË¶ÅÂÅöÁöÑÂá†‰ª∂‰∫ã]]></title>
    <url>%2F2018%2F05%2F30%2FAndroid%E5%BC%80%E5%8F%91%E8%80%85%E9%87%8D%E8%A3%85Ubuntu%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E5%87%A0%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[ÊèêÁ§∫Êñá‰∏≠ÊâÄÊúâËìùËâ≤ÊñáÂ≠óÈÉΩÊòØÂèØ‰ª•ÁÇπÂáªË∑≥ËΩ¨ÁöÑÂØπÂ∫îËØ¶ÁªÜÂú∞ÂùÄ Êõ¥Êñ∞1sudo apt-get update ÂÆâË£ÖÁ≥ªÁªüÂ∑•ÂÖ∑Vim1234#ÂÆâË£Ösudo apt install vim#ÈÖçÁΩÆvi ~/.vimrc Git1sudo apt-get install git Python12sudo apt-get install pythonsudo apt-get install python3 JDK1Ëß£ÂéãÂç≥ÂèØ ÂÆâË£ÖÂ∏∏Áî®ËΩØ‰ª∂Chrome1234wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key addsudo sh -c &apos;echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google-chrome.list&apos;sudo apt-get updatesudo apt-get install google-chrome-stable ÊêúÁãóËæìÂÖ•Ê≥ï123456789101112131415# ÂÆâË£ÖfcitxÈîÆÁõòËæìÂÖ•Ê≥ïÁ≥ªÁªüsudo add-apt-repository ppa:fcitx-team/nightlysudo apt-get updatesudo apt-get install fcitxsudo apt-get install fcitx-config-gtksudo apt-get install fcitx-table-allsudo apt-get install im-switch # ËæìÂÖ•Y# ‰∏ãËΩΩÊêúÁãóËæìÂÖ•Ê≥ïhttps://pinyin.sogou.com/linux/?r=pinyinsudo apt-get install -fsudo dpkg -i sogoupinyin_***.deb# Á≥ªÁªüÈªòËÆ§ÈîÆÁõòËæìÂÖ•Ê≥ïÁ≥ªÁªü‰ªéibus‰øÆÊîπ‰∏∫fcitx# Âú®ÂÆâË£ÖÁöÑFcitxÈÖçÁΩÆ‰∏≠(Â¶ÇÊûúÊ≤°Êúâ)Ê∑ªÂä†ÊêúÁãóËæìÂÖ•Ê≥ï# LogoutÂΩìÂâçÁî®Êà∑ Êà™ÂõæÂ∑•ÂÖ∑Shutter123456# ÂÆâË£Ösudo add-apt-repository ppa:shutter/ppasudo apt-get updatesudo apt-get install shutter# ËÆæÁΩÆÂø´Êç∑ÈîÆÁ≥ªÁªüËÆæÁΩÆÁöÑÈîÆÁõòËÆæÁΩÆ(ËØ¶ËßÅShutterÂØπÂ∫îÂú∞ÂùÄ) indicator-sysmonitor123sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor sudo apt-get update sudo apt-get install indicator-sysmonitor ÂÆâË£ÖIDEAndroid StudioÊ∑ªÂä†Android StudioÂõæÊ†áÂà∞Â∑¶‰æßÁöÑÂ∑•ÂÖ∑Ê†èÂú®Android StudioÊó∂Configure‰∏≠ÈÄâÊã©Create Desktop EntryÊàñËÄÖÂú®Android StudioÂêØÂä®ÂêéÂú® Help‰∏≠ÁöÑFind ActionÊêúÁ¥¢Create Desktop Entry ÈÖçÁΩÆÁéØÂ¢ÉÂèòÈáè‰øÆÊîπÊñá‰ª∂1sudo gedit .bashrc JAVA12345JAVA_HOME=/usr/java/jdk1.8.0_101 #Your Java pathJRE_HOME=$JAVA_HOME/jreJAVA_BIN=$JAVA_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin Android12export ANDROID_HOME=/home/android/Sdkexport PATH=$PATH:$ANDROID_HOME/tools/:$ANDROID_HOME/platform-tools/ Ê∑ªÂä†Âø´Êç∑ÂëΩ‰ª§1234567891011alias upload=&quot;repo upload .&quot;alias pull=&quot;git pull --rebase&quot;alias ba=&quot;git checkout alpha&quot;alias bd=&quot;git checkout dev&quot;alias add=&quot;git add .&quot;alias cm=&quot;git commit -s&quot;alias in=&quot;adb install -r&quot;alias ind=&quot;adb install -r /home/app/Demo/build/outputs/apk/debug.apk&quot;alias inr=&quot;adb install -r /home/app/Demo/build/outputs/apk/release.apk&quot;alias asd=&quot;./gradlew assembledebug&quot;alias asr=&quot;./gradlew assemblerelease&quot;]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Ëß£ÂéãÊñá‰ª∂‰∏≠ÊñáÂêç‰π±Á†Å]]></title>
    <url>%2F2018%2F05%2F04%2FUbuntu-%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E5%90%8D%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Ubuntu Ëß£ÂéãÊñá‰ª∂‰∏≠ÊñáÂêç‰π±Á†ÅËß£ÂÜ≥ÊñπÊ°à123sudo apt-get install unarunar Ëß£ÂéãÊñá‰ª∂ÂêçÁß∞ Have Fun:)]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IntentÂÆö‰πâÈÄâÊã©Âô®ÊâìÂºÄÁõ∏Êú∫ÂíåÁõ∏ÂÜå]]></title>
    <url>%2F2018%2F04%2F17%2FAndroid-Intent%E5%AE%9A%E4%B9%89%E9%80%89%E6%8B%A9%E5%99%A8%E6%89%93%E5%BC%80%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Android IntentÈÄâÊã©ÊâìÂºÄÁõ∏Êú∫ÂíåÁõ∏ÂÜåCSDNÂçöÂÆ¢ÂØπÂ∫îÊñáÁ´†Âú∞ÂùÄ ÈúÄÊ±Ç‰∏ä‰º†ÂõæÁâáÔºåÁÇπÂáªÊåâÈíÆÂºπÂá∫ÈÄâÊã©Áõ∏Êú∫ÊãçÁÖßÊàñËÄÖÁõ∏ÂÜåÈÄâÊã©ÁÖßÁâá Ëß£ÂÜ≥ÊñπÊ°àIntent.ACTION_CHOOSER ### ÊâìÂºÄÁõ∏Êú∫ 12Intent captureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);captureIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); ÊâìÂºÄÁõ∏ÂÜå12Intent albumIntent = new Intent(Intent.ACTION_PICK, null);albumIntent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;); ‰ΩøÁî®Intent.ACTION_CHOOSERÂ∞ÜÁõ∏Êú∫ÂíåÁõ∏ÂÜåÂêàÂú®‰∏ÄËµ∑123456789101112//ÂàõÂª∫ChooserIntentIntent intent = new Intent(Intent.ACTION_CHOOSER);//ÂàõÂª∫Áõ∏Êú∫IntentIntent captureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);captureIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);//Â∞ÜÁõ∏Êú∫Intent‰ª•Êï∞ÁªÑÂΩ¢ÂºèÊîæÂÖ•Intent.EXTRA_INITIAL_INTENTSintent.putExtra(Intent.EXTRA_INITIAL_INTENTS, new Intent&#123;captureIntent&#125;);//ÂàõÂª∫Áõ∏ÂÜåIntentIntent albumIntent = new Intent(Intent.ACTION_PICK, null);albumIntent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);//Â∞ÜÁõ∏ÂÜåIntentÊîæÂÖ•Intent.EXTRA_INTENTintent.putExtra(Intent.EXTRA_INTENT, albumIntent); Have Fun:)]]></content>
      <tags>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18.03ÊÄªÁªì]]></title>
    <url>%2F2018%2F03%2F29%2F18-03%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[‰∏âÊúàÊÄªÁªìÈ©æÊ†°ÁªÉËΩ¶ÔºåÈÄöËøáÁßëÁõÆ‰∫å‰∏âÊúàÁöÑÂõõ‰∏™Âë®Êú´Êúâ‰∏â‰∏™ÈÉΩÊòØÂú®È©æÊ†°Â∫¶ËøáÁöÑÔºå‰∏§‰∏™Âë®Êú´Â≠¶‰∫Ü7‰∏™Â≠¶Êó∂ÁöÑÁßëÁõÆ‰∫åÔºå‰πãÂâç‰ªéÊù•Ê≤°ÊúâÁ¢∞ËøáËΩ¶ÔºåÂàöÂºÄÂßãÂ≠¶ÁöÑÊó∂ÂÄôÔºåÈÅáÂà∞Á¥ßÊÄ•ÊÉÖÂÜµËÄÅÊòØÁåõÊùæÂàπËΩ¶ÔºåÂ∞±ÂØºËá¥ÁÜÑÁÅ´Ôºå‰∏ÄÁõ¥‰ª•‰∏∫ÂíåÊ∏∏ÊàèÈáå‰∏ÄÊ†∑ÔºåÂè™Ë¶ÅÊùæÂºÄÊâãÔºåËΩ¶ÈÄüÂ∞±‰ºöÈôç‰ΩéÔºåÂêéÊù•ÁÜüÊÇâ‰∫ÜÔºåÂ≠¶Ëµ∑Êù•‰πüÊå∫Âø´ÁöÑ„ÄÇÊúÄÁªàÈ°∫Âà©ÈÄöËøáËÄÉËØïÔºåÂõ†‰∏∫È©æÊ†°‰∫∫Â§öÔºåÈ¢ÑÁ∫¶ÁöÑÁßëÁõÆ‰∏âÂ∑≤ÁªèÂà∞‰∫ÜÂõõÊúàÂ∫ï„ÄÇ ËãπÊûúÁªà‰∫éËÉΩÂà∑ÂÖ¨‰∫§‰∫ÜÂú®‰∏âÊúàÁöÑÊúÄÂêé‰∏§Â§©ÔºåËãπÊûúÊé®ÈÄÅ‰∫ÜiOS11.3Ê≠£ÂºèÁâàÁöÑÊõ¥Êñ∞ÔºåËøôÊ¨°Êõ¥Êñ∞Â∏¶Êù•‰∫Ü‰∏çÂ∞ëÁöÑÊñ∞FeatureÔºåÂÖ∂‰∏≠ÊàëÊúÄÂñúÊ¨¢ÁöÑÂ∞±ÊòØÂèØ‰ª•ÊîØÊåÅÂåó‰∫¨Âíå‰∏äÊµ∑Âà∑ÂÖ¨‰∫§ÂíåÂú∞ÈìÅÔºåËôΩÁÑ∂ÊàëÁ±≥ÁöÑÊâãÊú∫Âú®15Âπ¥Â∞±ÂèØ‰ª•‰∫ÜÔºå‰ΩÜÊòØÂØπËãπÊûúÊù•ËØ¥ÔºåËøôÊòØÂõΩÂÜÖÊØîËæÉÂ§ßÁöÑÊú¨Âú∞ÂåñÂêßÔºåÂÆûÈôÖ‰ΩìÈ™å‰∫Ü‰∏Ä‰∏ãÔºåÂàöÂºÄÂßãÂõ†‰∏∫Âà∑Âç°ÊñπÂºè‰∏çÂØπÔºåÊï¥‰∏™ÊâãÊú∫Ë¥¥Âú®Âà∑Âç°Êú∫Âô®‰∏äÔºåÂá∫Áé∞‰∫Ü‰∏§Ê¨°Áõ¥Êé•Êâ£ÂÖ®Á®ãËΩ¶Ë¥πÁöÑÊÉÖÂÜµÔºå‰ΩÜÊòØÁúãÂà´‰∫∫ËØ¥Âú∞ÈìÅÈÉΩÊ≤°ÈóÆÈ¢òÔºåÊúÄÂàù‰ª•‰∏∫ÊòØÊúâ‰∫õÂÖ¨‰∫§ËΩ¶ÁöÑÂà∑Âç°Êú∫‰∏çÂ§™ÂÖºÂÆπÔºå‰ΩÜÊòØÂèàÊÉ≥Âà∞ÂÆâÂçìÊâãÊú∫Âà∑ÈÉΩÊ≤°ÊúâÈóÆÈ¢òÔºåÂêéÊù•Âú®ÂæÆÂçö‰∏äÁúãÂà∞‰∫ÜËØÑËÆ∫ËØ¥Ë¶ÅÁî®ÊâãÊú∫Â§¥ÈÉ®Ë¥¥Âú®Âà∑Âç°Êú∫Âô®‰∏äÔºå‰∏âÁßíÂ∑¶Âè≥ÔºåÊàñËÄÖÂê¨Âà∞Âà∑Âç°Êú∫Âô®Êª¥Â£∞ÂìçËµ∑Ôºå‰∏çËÉΩÂÉèÂÖ¨‰∫§Âç°‰∏ÄÊ†∑ÔºåÈáçÂ§çÂ§öÂà∑‰πü‰∏ç‰ºöÂ§öÊâ£Ê¨æÔºåÁÑ∂Âêé‰πãÂêéÈÉΩÊåâÁÖßËøôÊ†∑Êù•ÂÅöÔºåÊûúÁÑ∂Ê≤°ÊúâÂÜçÂá∫Á´ôÂéüÊù•ÁöÑÈóÆÈ¢ò„ÄÇÊúÄÂêéÈôÑ‰∏äÊàëÁöÑÂÖ¨‰ºóÂè∑ÂÖ≥‰∫éiPhoneÂºÄÈÄöÂÖ¨‰∫§Âç°ÁöÑÊïôÁ®ã]]></content>
      <tags>
        <tag>ÊÄªÁªì</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment getContext() NoSuchMethodError]]></title>
    <url>%2F2018%2F03%2F26%2FFragment-getContext-NoSuchMethodError%2F</url>
    <content type="text"><![CDATA[Fragment getContext() Âú®Android‰ΩéÁâàÊú¨ÔºàAPI&lt;=22Ôºâ‰∏≠Âá∫Áé∞NoSuchMethodErrorLogÊó•Âøó12345678910111213Exception java.lang.NoSuchMethodError: No virtual method getContext()Landroid/content/Context; in class Lcom/android/browser/preferences/MainPreferenceFragment; or its super classes (declaration of &apos;com.android.browser.preferences.MainPreferenceFragment&apos; appears in /system/priv-app/Browser/Browser.apk)com.android.browser.preferences.MainPreferenceFragment.onPreferenceChange (SourceFile:203)android.preference.Preference.callChangeListener (Preference.java:928)miui.support.preference.ListPreference.onDialogClosed (SourceFile:300)miui.support.preference.a.onDismiss (SourceFile:130)android.app.Dialog$ListenersHandler.handleMessage (Dialog.java:1263)android.os.Handler.dispatchMessage (Handler.java:102)android.os.Looper.loop (Looper.java:135)android.app.ActivityThread.main (ActivityThread.java:5296)java.lang.reflect.Method.invoke (Method.java)java.lang.reflect.Method.invoke (Method.java:372)com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:912)com.android.internal.os.ZygoteInit.main (ZygoteInit.java:707) ÂàáËÆ∞Fragment‰∏≠ÁöÑgetContext()ÊñπÊ≥ïÊòØÂú®Android6.0‰∏≠ÊâçÂá∫Áé∞ÁöÑÔºåÂú®‰Ωé‰∫éËØ•ÁâàÊú¨‰∏≠‰ΩøÁî®‰ºöÊä•NoSuchMethodErrorÔºåÂèØ‰ª•‰ΩøÁî®getActivity()Êù•ÊõøÊç¢„ÄÇ]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu extÁ°¨ÁõòÊùÉÈôê‰øÆÊîπ‰∏∫ÂΩìÂâçÁî®Êà∑]]></title>
    <url>%2F2018%2F03%2F15%2FUbuntu-ext%E7%A1%AC%E7%9B%98%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[CSDNÂçöÂÆ¢ÂØπÂ∫îÊñáÁ´†Âú∞ÂùÄ Áé∞Ë±°GUI‰∏ãÊüê‰∏™Êñá‰ª∂Â§πÂÜÖÊó†Ê≥ïÂàõÂª∫Êñá‰ª∂Â§π„ÄÅÂà†Èô§Êñá‰ª∂Á≠âÊìç‰ΩúÔºåÂè™ËÉΩÂú®ÁªàÁ´Ø‰∏≠Áî®sudo ÂëΩ‰ª§Êù•ÂàõÂª∫ÂíåÂà†Èô§Êñá‰ª∂„ÄÇ Ê†πÊú¨ÂéüÂõ†ÂΩìÂâçÊñá‰ª∂ÊâÄÂú®ÁöÑÁªÑÂ±û‰∫éroot ÊàëÁöÑÂéüÂõ†Windows+UbuntuÂèåÁ≥ªÁªüÔºåÂêéÊù•ÊääWindowsÁ≥ªÁªüÁöÑÂàÜÂå∫ÁªôÊ†ºÂºèÂåñ‰∫ÜÔºåËøõÂÖ•Ubuntu‰øÆÊîπ‰∏∫ext4Ê†ºÂºèÔºåÂá∫Áé∞‰∏äËø∞ÈóÆÈ¢ò„ÄÇ Ëß£ÂÜ≥ÊñπÊ°à12345whoami #Êü•ÁúãÂΩìÂâçÁî®Êà∑ÂêçÁß∞#Âú®Âá∫ÈóÆÈ¢òÁöÑÂàÜÂå∫‰∏≠ÊâìÂºÄÁªàÁ´ØÔºåÂèØ‰ª•ÁúãÂà∞ÊâÄÂú®‰ΩçÁΩÆÂíåÂàÜÂå∫ÁöÑÂêçÁß∞sudo chown -R username /media/username/diskname/ #ÂÖ∂‰∏≠ÁöÑusernameÂ∞±ÊòØwhoami‰∏≠Êü•Âá∫Êù•ÁöÑÔºådisknameÊòØÂàÜÂå∫ÂêçÁß∞sudo umount /media/username/diskname/reboot That‚Äôs all, have fun :)]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu HexoÊê≠Âª∫ÈúÄË¶ÅÈÖçÁΩÆnodejsÁéØÂ¢ÉÊó∂ÊèêÁ§∫ÁâàÊú¨Ëøá‰ΩéÁöÑÊñπÊ°à]]></title>
    <url>%2F2018%2F03%2F15%2FUbuntu-Hexo%E6%90%AD%E5%BB%BA%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AEnodejs%E7%8E%AF%E5%A2%83%E6%97%B6%E6%8F%90%E7%A4%BA%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E7%9A%84%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Ubuntu ÈÖçÁΩÆnodejsÁéØÂ¢É ‰ΩøÁî®sudo apt-get install nodejs Áõ¥Êé•ÂÆâË£ÖÁöÑnodejsÁâàÊú¨ÊòØ4.√óÁâàÊú¨ÔºåÂíåHexoÊê≠Âª∫ËøáÁ®ã‰∏≠ÈúÄË¶ÅÁöÑÁâàÊú¨‰∏çÂÖºÂÆπ„ÄÇÂèØ‰ª•ÂèÇËÄÉ‰∏äËø∞Âú∞ÂùÄ‰ΩøÁî®ÂÆâË£ÖnpnÂéªÊõ¥Êñ∞„ÄÇ]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android EditText ÈÄöËøáTextWatcherÂÆûÁé∞Ëá™Âä®Ë°•ÂÖ®ÁöÑÊ≥®ÊÑèÁÇπ]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-EditText-%E9%80%9A%E8%BF%87TextWatcher%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Android EditText ÈÄöËøáTextWatcherÂÆûÁé∞Ëá™Âä®Ë°•ÂÖ®ÁöÑÊ≥®ÊÑèÁÇπCSDNÊñáÁ´†ÂØπÂ∫îÂú∞ÂùÄ ËÉåÊôØÈúÄÊ±ÇÊÉ≥Ë¶ÅÂÆûÁé∞ËæìÂÖ•Ê°ÜÂú®Áî®Êà∑ËæìÂÖ•‰∫Ü‰∏ÄÂÆöÊñáÊú¨ÁöÑÊÉÖÂÜµ‰∏ã Ëá™Âä®Â°´ÂÖÖ‰∏Ä‰∏™ÂèØËÉΩÁî®Êà∑ÊÉ≥Ë¶ÅÁöÑÁªìÊûúÔºåÁ±ª‰ººChromeÊâãÊú∫ÁâàÁöÑÊêúÁ¥¢Ê°Ü ÂÆûÁé∞12345678910111213141516171819202122private class MyWatcher implements TextWatcher &#123; public void afterTextChanged(Editable s) &#123; Log.d(TAG, &quot;doAfterTextChanged..&quot;); if (‰∏Ä‰∫õÂèØËÉΩÈò≤Ê≠¢Ëá™Âä®Ë°•ÂÖ®ÁöÑÊÉÖÂÜµ) &#123; return; &#125; //‰∏∫‰∫ÜÈò≤Ê≠¢Âø´ÈÄüËæìÂÖ•ÁöÑÊÉÖÂÜµ‰∏ãÈáçÂ§çË∞ÉÁî®ÔºåÂä†‰∏Ä‰∏™Âª∂Êó∂ mHandler.removeMessages(MSG_AUTO_COMPLETE); mHandler.sendEmptyMessageDelayed(MSG_AUTO_COMPLETE, DELAY_AUTO_COMPLETE); &#125; public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; public void onTextChanged(CharSequence s, int start, int before, int count) &#123; //ËøôÈáåÂèØ‰ª•ËÆæÁΩÆ‰∏Ä‰∫õÊ†áÂøó‰ΩçÔºåÁî®‰∫éÈò≤Ê≠¢Ëá™Âä®Ë°•ÂÖ®ÔºåÊØîÂ¶ÇËøôÈáåÁöÑËØÜÂà´Áî®Êà∑Êåâ‰∫ÜÂà†Èô§ÊåâÈîÆÔºåÈÄöËøácount==0Êù•Âà§Êñ≠ mLastUrlEditWasDelete = (count == 0); &#125; &#125; ‰∏äÈù¢‰∏Ä‰∫õÂèØËÉΩÈò≤Ê≠¢Ëá™Âä®Ë°•ÂÖ®ÁöÑÊÉÖÂÜµÊúâÂæàÂ§öÔºå‰∏ÄËà¨ÊúâÔºö Áî®Êà∑ÁÇπ‰∫ÜÂà†Èô§ÈîÆÔºõ Ê≠£Âú®Â§Ñ‰∫é‰∏ä‰∏ÄÊ¨°Ëá™Âä®Ë°•ÂÖ®ÁöÑËøáÁ®ã‰∏≠Ôºõ Â≠òÂú®ÁöÑÂÖºÂÆπÊÄßÈóÆÈ¢òÂäüËÉΩ‰∏äÁ∫ø‰πãÂêéÔºåÂèëÁé∞ÂõΩÂ§ñÁöÑÁî®Êà∑Ëá™Âä®Ë°•ÂÖ®ÂêéÁÇπ‰∫ÜÂà†Èô§Ôºå‰ºöÂÜçÊ¨°Ëá™Âä®Ë°•ÂÖ®ÔºåÂØºËá¥ËæìÂÖ•Ê°ÜÊó†Ê≥ïÂà†Èô§ÔºåËøô‰∏™ÊòØÂæà‰∏•ÈáçÁöÑbugÔºå‰ΩÜÊòØÂú®ÊµãËØïÂíåÂºÄÂèëÁöÑËøáÁ®ã‰∏≠ÈÉΩÊ≤°ÊúâÂèëÁé∞ÔºåÂêéÊù•ÂèëÁé∞ÂõΩÂ§ñÁöÑÁî®Êà∑Áî®ÁöÑÊòØGboardËæìÂÖ•Ê≥ïÔºåÈªòËÆ§Êúâ‰∏Ä‰∏™ÊñáÊú¨ËæìÂÖ•Âª∫ËÆÆÔºåËÄåÂºÄÂèëÂíåÊµãËØïÈÉΩÁî®ÁöÑÂõΩÂÜÖÁöÑËæìÂÖ•Ê≥ïÔºåÊØîÂ¶ÇËÆØÈ£ûÂíåÊêúÁãóÁ≠âÁ≠â„ÄÇËøôÈáåÂ∞±Âá∫Áé∞‰∫ÜËæìÂÖ•Ê≥ïÁöÑÂÖºÂÆπÈóÆÈ¢òÔºå‰ΩøÁî®‰∏çÂêåÁöÑËæìÂÖ•Ê≥ïÔºåÁÇπÂáªÂà†Èô§Êó∂ÂõûË∞ÉÁöÑTextWatcherÁöÑÊ¨°Êï∞‰∏çÂêåÔºåÂú®ÁΩë‰∏äÊâæ‰∫ÜÂæàÂ§öËß£ÂÜ≥ÊñπÊ°àÔºåÊúÄÂ§öÁöÑÂ∞±ÊòØËØ¥ËÆ©ÁªôEditTextËÆæÁΩÆ‰∏Ä‰∏™ËæìÂÖ•Á±ªÂûãÔºå‰πüÂ∞±ÊòØinputType‰∏∫textNoSuggestionsÔºåËøòÊúâËØ¥Áî®textVisiblePasswordÁöÑÔºå‰ΩÜÊòØÂâçËÄÖtextNoSuggestionsÊµãËØïÊó†Áî®ÔºåÊó†Ê≥ïÊéßÂà∂Gboard‰∏çÊòæÁ§∫ËæìÂÖ•Âª∫ËÆÆÔºåÂêéËÄÖtextVisiblePassword‰ºöÂØºËá¥Âè™ËÉΩËæìÂÖ•Êï∞Â≠óÂíåËã±ÊñáÔºå‰ΩÜÊòØÊµ∑Â§ñÁöÑÁî®Êà∑Âπ∂‰∏çÈÉΩÊòØËæìÂÖ•Ëã±ÊñáÁöÑ„ÄÇÊâÄ‰ª•Ëøô‰∫õÈÉΩ‰∏çÊòØÁúüÊ≠£ÁöÑËß£ÂÜ≥ÊñπÊ°à ÊàñËÄÖËØ¥‰∏çÈÄÇÁî®‰∫éÁõÆÂâçÁöÑÊÉÖÂÜµ„ÄÇ Ëß£ÂÜ≥ÊñπÊ°àÂú®ÊòØÂê¶Ëá™Âä®Ë°•ÂÖ®ÁöÑÂú∞Êñπ‰∏ãÂäüÂ§´ÔºåÂà§Êñ≠Â§Ñ‰∫éËæìÂÖ•Ê≥ïÁöÑÂª∫ËÆÆË°•ÂÖ®ÁöÑÊó∂ÂÄôÂ∞±‰∏çËá™Âä®Ë°•ÂÖ®123456private boolean shouldAutoComplete() &#123; Editable text = getText(); return !isHandlingBatchInput() &amp;&amp; BaseInputConnection.getComposingSpanEnd(text) == BaseInputConnection.getComposingSpanStart(text);&#125; Áº∫ÊÜæÔºåËøôÊ†∑ÁöÑËØùÔºåÂè™ÊúâÁî®Êà∑ÁÇπÂáª‰∫ÜËæìÂÖ•Ê≥ïÂÜÖÁöÑÊêúÁ¥¢Âª∫ËÆÆÁöÑËØçÔºåËæìÂÖ•ÂÜÖÂÆπÊâç‰ºöÂá∫Áé∞Âú®EditText‰∏≠Ôºå‰ΩÜÊòØÊ≠§Êó∂‰∏ç‰ºöÊâßË°åËá™Âä®Ë°•ÂÖ®Êìç‰ΩúÔºåÊàëÁöÑËß£ÂÜ≥ÊñπÊ°àÊòØ‰ΩøÁî®Ëá™ÂÆö‰πâÁöÑInputConnectionWrapperÈáçÂÜôEditTextÁöÑonCreateInputConnectionÊñπÊ≥ïÔºå 123456789101112@Overridepublic InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; mInputConnectionWrapper.setTarget(super.onCreateInputConnection(outAttrs)); return InputConnectionWrapper;&#125;InputConnectionWrapper mInputConnectionWrapper = new InputConnectionWrapper(null, true) &#123; @Override public boolean finishComposingText() &#123; autoComplete(mLastSuggestion); return super.finishComposingText(); &#125;&#125;; Âú®finishComposingTextÁöÑÊó∂ÂÄôË∞ÉÁî®‰∏ÄÊ¨°Ëá™Â∑±ÂÜôÁöÑautoCompleteÊñπÊ≥ï„ÄÇ Have Fun~]]></content>
      <categories>
        <category>ÁßªÂä®ÂºÄÂèë</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TextWatcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23ÁßçËÆæËÆ°Ê®°ÂºèÂ§áÂøòÂíåÁêÜËß£‚Äî‚Äî1.ÂàÜÁ±ª]]></title>
    <url>%2F2018%2F03%2F09%2F23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%87%E5%BF%98%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ËÆæËÆ°Ê®°ÂºèÂàÜÁ±ªÂàõÂª∫Âûã-5Áßç Âçï‰æãÊ®°Âºè Âª∫ÈÄ†ËÄÖÊ®°Âºè ÂéüÂûãÊ®°Âºè Â∑•ÂéÇÊñπÊ≥ïÊ®°Âºè ÊäΩË±°Â∑•ÂéÇÊ®°ÂºèÁªìÊûÑÂûã-7Áßç ÈÄÇÈÖçÂô®Ê®°Âºè Ë£ÖÈ•∞ËÄÖÊ®°Âºè ÁªìÂêàÊ®°Âºè Ê°•Êé•Ê®°Âºè Â§ñËßÇÊ®°Âºè ‰∫´ÂÖÉÊ®°Âºè ‰ª£ÁêÜÊ®°ÂºèË°å‰∏∫Âûã-11Áßç Á≠ñÁï•Ê®°Âºè ËßÇÂØüËÄÖÊ®°Âºè Ëø≠‰ª£Âô®Ê®°Âºè ÂëΩ‰ª§Ê®°ÂºèÊ®°Âºè Â§áÂøòÂΩïÊ®°Âºè ‰∏≠‰ªãËÄÖÊ®°Âºè Ëß£ÈáäÂô®Ê®°Âºè ËÆøÈóÆËÄÖÊ®°Âºè Ë¥£‰ªªÈìæÊ®°Âºè Áä∂ÊÄÅÊ®°Âºè Ê®°ÊùøÊñπÊ≥ïÊ®°Âºè]]></content>
      <categories>
        <category>ËÆæËÆ°Ê®°Âºè</category>
      </categories>
      <tags>
        <tag>ËÆæËÆ°Ê®°Âºè</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ViewÁÑ¶ÁÇπËé∑Âèñ]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid%20View%E7%84%A6%E7%82%B9%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[ÈúÄÊ±ÇÊù•Ê∫êÊµãËØïÁªôÊèê‰∫Ü‰∏Ä‰∏™bugÔºåÂèëÁé∞ÊòØÁÑ¶ÁÇπËΩ¨ÁßªÂØºËá¥ÁöÑÔºåÊÉ≥ÁúãÁúãÊòØ‰ªéÂì™Âà∞Âì™ÂÑøËΩ¨Áßª‰∫Ü„ÄÇ ÊñπÊ°à‰∏∫‰∫ÜÂÆöÊó∂ËæìÂá∫ÂΩìÂâçËé∑ÂèñÁÑ¶ÁÇπÁöÑÊéß‰ª∂‰ø°ÊÅØÔºåÂèØ‰ª•Êñ∞ÂºÄ‰∏Ä‰∏™Á∫øÁ®ãÔºåÊØènÁßíË∞ÉÁî®‰∏Ä‰∏ãrootviewÁöÑfindFocus ÂÖ∑‰ΩìÂ¶Ç‰∏ã123456789101112131415new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; View rootview = BrowserActivity.this.getWindow().getDecorView(); View focusView = rootview.findFocus(); Log.i(&quot;LWQ&quot;, focusView == null ? &quot;ÂΩìÂâçÊó†ÁÑ¶ÁÇπ&quot; : focusView.toString()); &#125; &#125;&#125;).start();]]></content>
      <categories>
        <category>ÁßªÂä®ÂºÄÂèë</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UbuntuÁä∂ÊÄÅÊ†èÂíå‰æßËæπÊ†èÊ∂àÂ§±Ëß£ÂÜ≥ÊñπÊ°à‚Äî‚ÄîÂà†Èô§iBusÂºïËµ∑]]></title>
    <url>%2F2018%2F03%2F09%2FUbuntu%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4iBus%E5%BC%95%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[UbuntuÂà†Èô§iBusÂêéÁä∂ÊÄÅÊ†èÂíå‰æßËæπÊ†èÊ∂àÂ§±Ëß£ÂÜ≥ÊñπÊ°àCSDNÊñáÁ´†ÂØπÂ∫îÂú∞ÂùÄ Ëµ∑Âõ†ÁúãÂà∞ÁΩë‰∏äÁöÑ‰ºòÂåñÊïôÁ®ãËØ¥Áî®‰∫ÜfctixÂ∞±‰∏çÁî®iBus‰∫ÜÔºå‰∫éÊòØÂ∞±Âç∏ËΩΩ‰∫ÜiBusÔºåÊ≤°ÊÉ≥Ë¶ÅÁöÑÊòØÂõ†‰∏∫ÊúâÂæàÂ§öÂÖ∂‰ªñÁöÑËΩØ‰ª∂‰ºöÊúâ‰æùËµñÔºåÊØîÂ¶ÇÂíåÁïåÈù¢Áé∞ÂÆûÊúâÂÖ≥Á≥ªÁöÑUnity„ÄÇ Ëß£ÂÜ≥ÊñπÊ°àÁªàÁ´Ø‰∏ãËæìÂÖ• 123dconf reset -f /org/compiz #ÈáçÁΩÆcompizsudo apt install unity #Â¶ÇÊûúunityË¢´Âç∏ËΩΩ‰∫ÜÔºåÈáçË£Öunitysetsid unity #ÈáçÂêØuni]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome for Android AutoCompleteÂú∞ÂùÄÊ†èÂú∞ÂùÄËá™Âä®Ë°•ÂÖ®ÂäüËÉΩË∞ÉÁ†îÂíåÊõ¥Êñ∞]]></title>
    <url>%2F2018%2F03%2F09%2FChrome-for-Android-AutoComplete%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD%E8%B0%83%E7%A0%94%E5%92%8C%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[ChromeÂú∞ÂùÄÊ†èÂú∞ÂùÄËá™Âä®Ë°•ÂÖ®ÂäüËÉΩË∞ÉÁ†îÂíåÊõ¥Êñ∞CSDNÊñáÁ´†ÂØπÂ∫îÂú∞ÂùÄ ChromeÂú∞ÂùÄÊ†èÂú∞ÂùÄËá™Âä®Ë°•ÂÖ®ÂäüËÉΩÈ¢ÑËßàË°•ÂÖ®ÂâçÊèêÔºö ‰ΩøÁî®GboardËæìÂÖ•Ê≥ï GboardËæìÂÖ•Ê≥ïÊâìÂºÄ‰∫Ü„ÄêÊñáÂ≠óÊõ¥Ê≠£„ÄëÂäüËÉΩÈáåÈù¢ÁöÑÁé∞ÂÆûÂª∫ËÆÆÊ†èË°•ÂÖ®ÈÄªËæëÔºö ËæìÂÖ•‰∏Ä‰∏™Â≠óÁ¨¶ÂêéÔºåÂ∞ÜÊé®ËçêÁöÑÁ¨¨‰∏Ä‰∏™ÈìæÊé•Ë°•ÂÖ®ÔºåË°•ÂÖ®ÁöÑÊñáÂ≠ó‰∏∫ËìùËâ≤ËÉåÊôØÈÄâ‰∏≠Áä∂ÊÄÅÔºåÂπ∂‰∏îÁî®Êà∑Ëá™Â∑±ËæìÂÖ•ÁöÑÊñáÊú¨‰∏ãÈù¢Êúâ‰∏ãÂàíÁ∫øÔºàËøô‰∏™‰∏ãÂàíÁ∫ø‰∏çÊòØËá™Â∑±ÈÄöËøáSpannableStringÊù•ÂÆûÁé∞ÁöÑÔºåÂ∫îËØ•ÊòØEditTextËá™Â∑±‰∏∫ÂæÖÁî®Êà∑ÈÄâÊã©Êé®ËçêÔºàcommitTextÔºâÁöÑÁöÑÊñáÊú¨ÈªòËÆ§Ê∑ªÂä†ÁöÑÔºâ ËæìÂÖ•‰∏Ä‰∏™ÈùûÂ≠óÊØçÁ±ªÂûãÁöÑÔºå‰ºöËá™Âä®commitTextÔºå‰ΩÜÊòØÊ≠§Êó∂ÊääÈùûÂ≠óÊØçÁ±ªÂûãÁöÑÂ≠óÁ¨¶Âà†Èô§ÂêéÔºåËæìÂÖ•Ê≥ïÁöÑËæìÂÖ•Âª∫ËÆÆ‰ºöÂÜçÊ¨°Âá∫Áé∞ÔºåÂπ∂‰∏î‰πãÂâçÁöÑÁî®Êà∑ËæìÂÖ•ÊñáÊú¨‰ºöÂÜçÊ¨°Âá∫Áé∞‰∏ãÂàíÁ∫øÔºåËøôÁßçÁä∂ÊÄÅÂÖ∂ÂÆûÂ∞±ÊòØÂ∏¶ÈÄâÊã©Áä∂ÊÄÅÔºåÂèØ‰ª•ÈÄöËøáËæìÂÖ•Ê≥ïÊúÄÈ°∂ÈÉ®ÁöÑÊé®ËçêÁõ¥Êé•ÊõøÊç¢ÊñáÂ≠ó„ÄÇ ÈÄâÊã©‰∫ÜËæìÂÖ•Ê≥ïÁöÑËæìÂÖ•Âª∫ËÆÆÊñáÊú¨ÔºåÊµèËßàÂô®‰πüËÉΩÁªßÁª≠ËøõË°åËæìÂÖ•Êé®ËçêÂíåËá™Âä®Ë°•ÂÖ® ÊúÄÂàùÁâàÊú¨ÊÉÖÂÜµChrome‰πãÂâçÁöÑÁâàÊú¨ÂÖ∂ÂÆû‰∏çÊòØËøôÊ†∑ÁöÑÔºåËÄåÊòØÁ±ª‰ºº‰∫éÁ¶ÅÁî®‰∫ÜËæìÂÖ•Ê≥ïÁöÑËæìÂÖ•Âª∫ËÆÆÔºåËÄåÁõ¥Êé•ÊõøÊç¢ËæìÂÖ•Ê°ÜÁöÑÊñáÊú¨ÔºåÂÜçÂ∞Ü‰∏ÄÈÉ®ÂàÜÊñáÂ≠óËÆæÁΩÆ‰∏∫selectÁä∂ÊÄÅ„ÄÇ‰ª£Á†ÅÂÆûÁé∞ÂèÇËÄÉÔºåAndroid EditText ÈÄöËøáTextWatcherÂÆûÁé∞Ëá™Âä®Ë°•ÂÖ®ÁöÑÊ≥®ÊÑèÁÇπ ChromeÊúÄÊñ∞Áâà‰ª£Á†ÅÂÆûÁé∞ÊïàÊûú ÂÆûÁé∞‰ª£Á†Å‰∏ªË¶ÅÊ†∏ÂøÉ‰ª£Á†ÅÔºåÂøΩÁï•‰∫Ü‰∏Ä‰∫õÂèòÈáèÁöÑÂÆö‰πâÔºåËØ¶ÁªÜÂèÇËÄÉChromeÊ∫êÁ†ÅÂç≥ÂèØ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765public void onAutoComplete(String suggestion) &#123; String userText = getTextWithoutAutocomplete(); suggestion = suggestion.startsWith(userText) ? suggestion.replaceFirst(userText, &quot;&quot;) : &quot;&quot;; if (shouldAutocomplete()) &#123; setAutocompleteText(userText, suggestion); &#125; &#125; private void limitDisplayableLength() &#123; // To limit displayable length we replace middle portion of the string with ellipsis. // That affects only presentation of the text, and doesn&apos;t affect other aspects like // copying to the clipboard, getting text with getText(), etc. final int maxLength = MAX_DISPLAYABLE_LENGTH_END; Editable text = getText(); int textLength = text.length(); if (textLength &lt;= maxLength) &#123; if (mDidEllipsizeTextHint) &#123; EllipsisSpan[] spans = text.getSpans(0, textLength, EllipsisSpan.class); if (spans != null &amp;&amp; spans.length &gt; 0) &#123; assert spans.length == 1 : &quot;Should never apply more than a single EllipsisSpan&quot;; for (int i = 0; i &lt; spans.length; i++) &#123; text.removeSpan(spans[i]); &#125; &#125; &#125; mDidEllipsizeTextHint = false; return; &#125; mDidEllipsizeTextHint = true; int spanLeft = text.nextSpanTransition(0, textLength, EllipsisSpan.class); if (spanLeft != textLength) return; spanLeft = maxLength / 2; text.setSpan(EllipsisSpan.INSTANCE, spanLeft, textLength - spanLeft, Editable.SPAN_INCLUSIVE_EXCLUSIVE); &#125; public boolean shouldAutocomplete() &#123; boolean retVal = mBatchEditNestCount == 0 &amp;&amp; mLastEditWasTyping &amp;&amp; mCurrentState.isCursorAtEndOfUserText() &amp;&amp; !isKeyboardBlacklisted() &amp;&amp; isNonCompositionalText(getTextWithoutAutocomplete()); Log.i(TAG, &quot;shouldAutocomplete: &quot; + retVal); return retVal; &#125; private boolean isKeyboardBlacklisted() &#123; String pkgName = getKeyboardPackageName(); return pkgName.contains(&quot;.iqqi&quot;) // crbug.com/767016 || pkgName.contains(&quot;omronsoft&quot;) || pkgName.contains(&quot;.iwnn&quot;); // crbug.com/758443 &#125; public String getKeyboardPackageName() &#123; String defaultIme = Settings.Secure.getString( getContext().getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD); return defaultIme == null ? &quot;&quot; : defaultIme; &#125; public static boolean isNonCompositionalText(String text) &#123; // To start with, we are only activating this for English alphabets, European characters, // numbers and URLs to avoid potential bad interactions with more complex IMEs. // The rationale for including character sets with diacritical marks is that backspacing on // a letter with a diacritical mark most likely deletes the whole character instead of // removing the diacritical mark. // TODO(changwan): also scan for other traditionally non-IME charsets. return NON_COMPOSITIONAL_TEXT_PATTERN.matcher(text).matches(); &#125; @Override protected void onSelectionChanged(int selStart, int selEnd) &#123; if (mCurrentState == null) &#123; return; &#125; if (mCurrentState.getSelStart() == selStart &amp;&amp; mCurrentState.getSelEnd() == selEnd) return; mCurrentState.setSelection(selStart, selEnd); if (mBatchEditNestCount &gt; 0) return; int len = mCurrentState.getUserText().length(); if (mCurrentState.hasAutocompleteText()) &#123; if (selStart &gt; len || selEnd &gt; len) &#123; Log.i(TAG, &quot;Autocomplete text is being touched. Make it real.&quot;); if (mInputConnection != null) mInputConnection.commitAutocomplete(); &#125; else &#123; Log.i(TAG, &quot;Touching before the cursor removes autocomplete.&quot;); clearAutocompleteTextAndUpdateSpanCursor(); &#125; &#125; notifyAutocompleteTextStateChanged(); &#125; private void clearAutocompleteTextAndUpdateSpanCursor() &#123; Log.i(TAG, &quot;clearAutocompleteAndUpdateSpanCursor&quot;); clearAutocompleteText(); // Take effect and notify if not already in a batch edit. if (mInputConnection != null) &#123; mInputConnection.onBeginImeCommand(); mInputConnection.onEndImeCommand(); &#125; else &#123; mSpanCursorController.removeSpan(); notifyAutocompleteTextStateChanged(); &#125; &#125;class AutocompleteState &#123; private String mUserText; private String mAutocompleteText; private int mSelStart; private int mSelEnd; public AutocompleteState(AutocompleteState a) &#123; copyFrom(a); &#125; public AutocompleteState(String userText, String autocompleteText, int selStart, int selEnd) &#123; set(userText, autocompleteText, selStart, selEnd); &#125; public void set(String userText, String autocompleteText, int selStart, int selEnd) &#123; mUserText = userText; mAutocompleteText = autocompleteText; mSelStart = selStart; mSelEnd = selEnd; &#125; public void copyFrom(AutocompleteState a) &#123; set(a.mUserText, a.mAutocompleteText, a.mSelStart, a.mSelEnd); &#125; public String getUserText() &#123; return mUserText; &#125; public String getAutocompleteText() &#123; return mAutocompleteText; &#125; public boolean hasAutocompleteText() &#123; return !TextUtils.isEmpty(mAutocompleteText); &#125; /** @return The whole text including autocomplete text. */ public String getText() &#123; return mUserText + mAutocompleteText; &#125; public int getSelStart() &#123; return mSelStart; &#125; public int getSelEnd() &#123; return mSelEnd; &#125; public void setSelection(int selStart, int selEnd) &#123; mSelStart = selStart; mSelEnd = selEnd; &#125; public void setUserText(String userText) &#123; mUserText = userText; &#125; public void setAutocompleteText(String autocompleteText) &#123; mAutocompleteText = autocompleteText; &#125; public void clearAutocompleteText() &#123; mAutocompleteText = &quot;&quot;; &#125; public boolean isCursorAtEndOfUserText() &#123; return mSelStart == mUserText.length() &amp;&amp; mSelEnd == mUserText.length(); &#125; public boolean isWholeUserTextSelected() &#123; return mSelStart == 0 &amp;&amp; mSelEnd == mUserText.length(); &#125; /** * @param prevState The previous state to compare the current state with. * @return Whether the current state is backward-deleted from prevState. */ public boolean isBackwardDeletedFrom(AutocompleteState prevState) &#123; return isCursorAtEndOfUserText() &amp;&amp; prevState.isCursorAtEndOfUserText() &amp;&amp; isPrefix(mUserText, prevState.mUserText); &#125; /** * @param prevState The previous state to compare the current state with. * @return Whether the current state is forward-typed from prevState. */ public boolean isForwardTypedFrom(AutocompleteState prevState) &#123; return isCursorAtEndOfUserText() &amp;&amp; prevState.isCursorAtEndOfUserText() &amp;&amp; isPrefix(prevState.mUserText, mUserText); &#125; /** * @param prevState The previous state to compare the current state with. * @return The differential string that has been backward deleted. */ public String getBackwardDeletedTextFrom(AutocompleteState prevState) &#123; if (!isBackwardDeletedFrom(prevState)) return null; return prevState.mUserText.substring(mUserText.length()); &#125; public boolean isPrefix(String a, String b) &#123; return b.startsWith(a) &amp;&amp; b.length() &gt; a.length(); &#125; /** * When the user manually types the next character that was already suggested in the previous * autocomplete, then the suggestion is still valid if we simply remove one character from the * beginning of it. For example, if prev = &quot;a[bc]&quot; and current text is &quot;ab&quot;, this method * constructs &quot;ab[c]&quot;. * @param prevState The previous state. * @return Whether the shifting was successful. */ public boolean reuseAutocompleteTextIfPrefixExtension(AutocompleteState prevState) &#123; // Shift when user text has grown or remains the same, but still prefix of prevState&apos;s whole // text. int diff = mUserText.length() - prevState.mUserText.length(); if (diff &lt; 0) return false; if (!isPrefix(mUserText, prevState.getText())) return false; mAutocompleteText = prevState.mAutocompleteText.substring(diff); return true; &#125; public void commitAutocompleteText() &#123; mUserText += mAutocompleteText; mAutocompleteText = &quot;&quot;; &#125; @Override public boolean equals(Object o) &#123; if (!(o instanceof AutocompleteState)) return false; if (o == this) return true; AutocompleteState a = (AutocompleteState) o; return mUserText.equals(a.mUserText) &amp;&amp; mAutocompleteText.equals(a.mAutocompleteText) &amp;&amp; mSelStart == a.mSelStart &amp;&amp; mSelEnd == a.mSelEnd; &#125; @Override public int hashCode() &#123; return mUserText.hashCode() * 2 + mAutocompleteText.hashCode() * 3 + mSelStart * 5 + mSelEnd * 7; &#125; @Override public String toString() &#123; return String.format(Locale.US, &quot;AutocompleteState &#123;[%s][%s] [%d-%d]&#125;&quot;, mUserText, mAutocompleteText, mSelStart, mSelEnd); &#125; &#125; public boolean hasAutocomplete() &#123; boolean retVal = mCurrentState.hasAutocompleteText(); Log.i(TAG, &quot;hasAutocomplete: &quot; + retVal); return retVal; &#125; private class AutocompleteInputConnection extends InputConnectionWrapper &#123; private final AutocompleteState mPreBatchEditState; public AutocompleteInputConnection() &#123; super(null, true); mPreBatchEditState = new AutocompleteState(mCurrentState); &#125; private boolean incrementBatchEditCount() &#123; ++mBatchEditNestCount; // After the outermost super.beginBatchEdit(), EditText will stop selection change // update to the IME app. return super.beginBatchEdit(); &#125; private boolean decrementBatchEditCount() &#123; --mBatchEditNestCount; return super.endBatchEdit(); &#125; public void commitAutocomplete() &#123; Log.i(TAG, &quot;commitAutocomplete&quot;); if (!hasAutocomplete()) return; mCurrentState.commitAutocompleteText(); // Invalidate mPreviouslySetState. mPreviouslySetState.copyFrom(mCurrentState); mLastEditWasTyping = false; incrementBatchEditCount(); // avoids additional notifyAutocompleteTextStateChanged() mSpanCursorController.commitSpan(); decrementBatchEditCount(); &#125; @Override public boolean beginBatchEdit() &#123; Log.i(TAG, &quot;beginBatchEdit&quot;); onBeginImeCommand(); boolean retVal = incrementBatchEditCount(); onEndImeCommand(); return retVal; &#125; /** * Always call this at the beginning of any IME command. Compare this with beginBatchEdit() * which is by itself an IME command. * @return Whether the call was successful. */ public boolean onBeginImeCommand() &#123; Log.i(TAG, &quot;onBeginImeCommand: &quot; + mBatchEditNestCount); boolean retVal = incrementBatchEditCount(); if (mBatchEditNestCount == 1) &#123; mPreBatchEditState.copyFrom(mCurrentState); &#125; else if (mDeletePostfixOnNextBeginImeCommand &gt; 0) &#123; int len = getText().length(); getText().delete(len - mDeletePostfixOnNextBeginImeCommand, len); &#125; mDeletePostfixOnNextBeginImeCommand = 0; mSpanCursorController.removeSpan(); return retVal; &#125; private void restoreBackspacedText(String diff) &#123; Log.i(TAG, &quot;restoreBackspacedText. diff: &quot; + diff); if (mBatchEditNestCount &gt; 0) &#123; // If batch edit hasn&apos;t finished, we will restore backspaced text only for visual // effects. However, for internal operations to work correctly, we need to remove // the restored diff at the beginning of next IME operation. mDeletePostfixOnNextBeginImeCommand = diff.length(); &#125; if (mBatchEditNestCount == 0) &#123; // only at the outermost batch edit if (shouldFinishCompositionOnDeletion()) super.finishComposingText(); &#125; incrementBatchEditCount(); // avoids additional notifyAutocompleteTextStateChanged() Editable editable = getEditableText(); editable.append(diff); decrementBatchEditCount(); &#125; private boolean setAutocompleteSpan() &#123; mSpanCursorController.removeSpan(); if (!mCurrentState.isCursorAtEndOfUserText()) return false; if (mCurrentState.reuseAutocompleteTextIfPrefixExtension(mPreviouslySetState)) &#123; mSpanCursorController.setSpan(mCurrentState); return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean endBatchEdit() &#123; Log.i(TAG, &quot;endBatchEdit&quot;); onBeginImeCommand(); boolean retVal = decrementBatchEditCount(); onEndImeCommand(); return retVal; &#125; /** * Always call this at the end of an IME command. Compare this with endBatchEdit() * which is by itself an IME command. * @return Whether the call was successful. */ public boolean onEndImeCommand() &#123; Log.i(TAG, &quot;onEndImeCommand: &quot; + (mBatchEditNestCount - 1)); String diff = mCurrentState.getBackwardDeletedTextFrom(mPreBatchEditState); if (diff != null) &#123; // Update selection first such that keyboard app gets what it expects. boolean retVal = decrementBatchEditCount(); if (mPreBatchEditState.hasAutocompleteText()) &#123; // Undo delete to retain the last character and only remove autocomplete text. restoreBackspacedText(diff); &#125; mLastEditWasTyping = false; clearAutocompleteText(); notifyAutocompleteTextStateChanged(); return retVal; &#125; if (!setAutocompleteSpan()) &#123; clearAutocompleteText(); &#125; boolean retVal = decrementBatchEditCount(); // Simply typed some characters or whole text selection has been overridden. if (mCurrentState.isForwardTypedFrom(mPreBatchEditState) || (mPreBatchEditState.isWholeUserTextSelected() &amp;&amp; mCurrentState.getUserText().length() &gt; 0 &amp;&amp; mCurrentState.isCursorAtEndOfUserText())) &#123; mLastEditWasTyping = true; &#125; notifyAutocompleteTextStateChanged(); return retVal; &#125; @Override public boolean commitText(CharSequence text, int newCursorPosition) &#123; Log.i(TAG, &quot;commitText: &quot; + text); onBeginImeCommand(); boolean retVal = super.commitText(text, newCursorPosition); onEndImeCommand(); return retVal; &#125; @Override public boolean setComposingText(CharSequence text, int newCursorPosition) &#123; Log.i(TAG, &quot;setComposingText: &quot; + text); onBeginImeCommand(); boolean retVal = super.setComposingText(text, newCursorPosition); onEndImeCommand(); return retVal; &#125; @Override public boolean setComposingRegion(int start, int end) &#123; onBeginImeCommand(); boolean retVal = super.setComposingRegion(start, end); onEndImeCommand(); return retVal; &#125; @Override public boolean finishComposingText() &#123; Log.i(TAG, &quot;finishComposingText&quot;); onBeginImeCommand(); boolean retVal = super.finishComposingText(); onEndImeCommand(); return retVal; &#125; @Override public boolean deleteSurroundingText(final int beforeLength, final int afterLength) &#123; onBeginImeCommand(); boolean retVal = super.deleteSurroundingText(beforeLength, afterLength); onEndImeCommand(); return retVal; &#125; @Override public boolean setSelection(final int start, final int end) &#123; onBeginImeCommand(); boolean retVal = super.setSelection(start, end); onEndImeCommand(); return retVal; &#125; @Override public boolean performEditorAction(final int editorAction) &#123; Log.i(TAG, &quot;performEditorAction: &quot; + editorAction); onBeginImeCommand(); commitAutocomplete(); boolean retVal = super.performEditorAction(editorAction); onEndImeCommand(); return retVal; &#125; @Override public boolean sendKeyEvent(final KeyEvent event) &#123; Log.i(TAG, &quot;sendKeyEvent: &quot; + event.getKeyCode()); onBeginImeCommand(); boolean retVal = super.sendKeyEvent(event); onEndImeCommand(); return retVal; &#125; @Override public ExtractedText getExtractedText(final ExtractedTextRequest request, final int flags) &#123; Log.i(TAG, &quot;getExtractedText&quot;); onBeginImeCommand(); ExtractedText retVal = super.getExtractedText(request, flags); onEndImeCommand(); return retVal; &#125; @Override public CharSequence getTextAfterCursor(final int n, final int flags) &#123; Log.i(TAG, &quot;getTextAfterCursor&quot;); onBeginImeCommand(); CharSequence retVal = super.getTextAfterCursor(n, flags); onEndImeCommand(); return retVal; &#125; @Override public CharSequence getTextBeforeCursor(final int n, final int flags) &#123; Log.i(TAG, &quot;getTextBeforeCursor&quot;); onBeginImeCommand(); CharSequence retVal = super.getTextBeforeCursor(n, flags); onEndImeCommand(); return retVal; &#125; @Override public CharSequence getSelectedText(final int flags) &#123; Log.i(TAG, &quot;getSelectedText&quot;); onBeginImeCommand(); CharSequence retVal = super.getSelectedText(flags); onEndImeCommand(); return retVal; &#125; @Override public boolean commitCompletion(CompletionInfo text) &#123; Log.i(TAG, &quot;commitCompletion&quot;); onBeginImeCommand(); boolean retVal = super.commitCompletion(text); onEndImeCommand(); return retVal; &#125; @Override public boolean commitContent(InputContentInfo inputContentInfo, int flags, Bundle opts) &#123; Log.i(TAG, &quot;commitContent&quot;); onBeginImeCommand(); boolean retVal = super.commitContent(inputContentInfo, flags, opts); onEndImeCommand(); return retVal; &#125; @Override public boolean commitCorrection(CorrectionInfo correctionInfo) &#123; Log.i(TAG, &quot;commitCorrection&quot;); onBeginImeCommand(); boolean retVal = super.commitCorrection(correctionInfo); onEndImeCommand(); return retVal; &#125; @Override public boolean deleteSurroundingTextInCodePoints(int beforeLength, int afterLength) &#123; Log.i(TAG, &quot;deleteSurroundingTextInCodePoints&quot;); onBeginImeCommand(); boolean retVal = super.deleteSurroundingTextInCodePoints(beforeLength, afterLength); onEndImeCommand(); return retVal; &#125; @Override public int getCursorCapsMode(int reqModes) &#123; Log.i(TAG, &quot;getCursorCapsMode&quot;); onBeginImeCommand(); int retVal = super.getCursorCapsMode(reqModes); onEndImeCommand(); return retVal; &#125; @Override public boolean requestCursorUpdates(int cursorUpdateMode) &#123; Log.i(TAG, &quot;requestCursorUpdates&quot;); onBeginImeCommand(); boolean retVal = super.requestCursorUpdates(cursorUpdateMode); onEndImeCommand(); return retVal; &#125; @Override public boolean clearMetaKeyStates(int states) &#123; Log.i(TAG, &quot;clearMetaKeyStates&quot;); onBeginImeCommand(); boolean retVal = super.clearMetaKeyStates(states); onEndImeCommand(); return retVal; &#125; &#125; private boolean shouldFinishCompositionOnDeletion() &#123; String defaultIme = Settings.Secure.getString( getContext().getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD); defaultIme = defaultIme == null ? &quot;&quot; : defaultIme; return !defaultIme.contains(&quot;com.sec.android.inputmethod&quot;); &#125; private int mDeletePostfixOnNextBeginImeCommand; private void clearAutocompleteText() &#123; Log.i(TAG, &quot;clearAutocomplete&quot;); mPreviouslySetState.clearAutocompleteText(); mCurrentState.clearAutocompleteText(); &#125; private final AutocompleteState mPreviouslyNotifiedState; private void notifyAutocompleteTextStateChanged() &#123; if (mBatchEditNestCount &gt; 0) &#123; // crbug.com/764749 Log.w(TAG, &quot;Did not notify - in batch edit.&quot;); return; &#125; if (mCurrentState.equals(mPreviouslyNotifiedState)) &#123; // crbug.com/764749 Log.w(TAG, &quot;Did not notify - no change.&quot;); return; &#125; if (mCurrentState.getUserText().equals(mPreviouslyNotifiedState.getUserText()) &amp;&amp; (mCurrentState.hasAutocompleteText() || !mPreviouslyNotifiedState.hasAutocompleteText())) &#123; // Nothing has changed except that autocomplete text has been set or modified. Or // selection change did not affect autocomplete text. Autocomplete text is set by the // controller, so only text change or deletion of autocomplete text should be notified. mPreviouslyNotifiedState.copyFrom(mCurrentState); return; &#125; mPreviouslyNotifiedState.copyFrom(mCurrentState); if (mIgnoreTextChangeFromAutocomplete) &#123; // crbug.com/764749 Log.w(TAG, &quot;Did not notify - ignored.&quot;); return; &#125; // The current model&apos;s mechanism always moves the cursor at the end of user text, so we // don&apos;t need to update the display. onAutocompleteTextStateChanged(false /* updateDisplay */); &#125; private static class SpanCursorController &#123; private final PopUpWindowInAutoCompleteTextView mDelegate; private BackgroundColorSpan mSpan; public SpanCursorController(PopUpWindowInAutoCompleteTextView delegate) &#123; mDelegate = delegate; &#125; public void setSpan(AutocompleteState state) &#123; int sel = state.getSelStart(); if (mSpan == null) mSpan = new BackgroundColorSpan(mDelegate.getHighlightColor()); SpannableString spanString = new SpannableString(state.getAutocompleteText()); // The flag here helps make sure that span does not get spill to other part of the text. spanString.setSpan(mSpan, 0, state.getAutocompleteText().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Editable editable = mDelegate.getEditableText(); editable.append(spanString); // Keep the original selection before adding spannable string. Selection.setSelection(editable, sel, sel); setCursorVisible(false); Log.i(TAG, &quot;setSpan: &quot; + getEditableDebugString(editable)); &#125; private void setCursorVisible(boolean visible) &#123; if (mDelegate.isFocused()) mDelegate.setCursorVisible(visible); &#125; private int getSpanIndex(Editable editable) &#123; if (editable == null || mSpan == null) return -1; return editable.getSpanStart(mSpan); // returns -1 if mSpan is not attached &#125; public void reset() &#123; setCursorVisible(true); Editable editable = mDelegate.getEditableText(); int idx = getSpanIndex(editable); if (idx != -1) &#123; editable.removeSpan(mSpan); &#125; mSpan = null; &#125; public boolean removeSpan() &#123; setCursorVisible(true); Editable editable = mDelegate.getEditableText(); int idx = getSpanIndex(editable); if (idx == -1) return false; editable.removeSpan(mSpan); editable.delete(idx, editable.length()); mSpan = null; &#123; Log.i(TAG, &quot;removeSpan - after removal: &quot; + getEditableDebugString(editable)); &#125; return true; &#125; public void commitSpan() &#123; mDelegate.getEditableText().removeSpan(mSpan); setCursorVisible(true); &#125; public void reflectTextUpdateInState(AutocompleteState state, CharSequence text) &#123; if (text instanceof Editable) &#123; Editable editable = (Editable) text; int idx = getSpanIndex(editable); if (idx != -1) &#123; // We do not set autocomplete text here as model should solely control it. state.setUserText(editable.subSequence(0, idx).toString()); return; &#125; &#125; state.setUserText(text.toString()); &#125; &#125; /** * @param editable The editable. * @return Debug string for the given &#123;@Editable&#125;. */ private static String getEditableDebugString(Editable editable) &#123; return String.format(Locale.US, &quot;Editable &#123;[%s] SEL[%d %d] COM[%d %d]&#125;&quot;, editable.toString(), Selection.getSelectionStart(editable), Selection.getSelectionEnd(editable), BaseInputConnection.getComposingSpanStart(editable), BaseInputConnection.getComposingSpanEnd(editable)); &#125; @Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; Log.i(TAG, &quot;onTextChanged: &quot; + text); if(mSpanCursorController==null)&#123; return; &#125; mSpanCursorController.reflectTextUpdateInState(mCurrentState, text); if (mBatchEditNestCount &gt; 0) return; // let endBatchEdit() handles changes from IME. // An external change such as text paste occurred. mLastEditWasTyping = false; clearAutocompleteTextAndUpdateSpanCursor(); &#125; public String getTextWithoutAutocomplete() &#123; String retVal = mCurrentState.getUserText(); Log.i(TAG, &quot;getTextWithoutAutocomplete: &quot; + retVal); return retVal; &#125; public void onAutocompleteTextStateChanged(boolean updateDisplay) &#123; if (updateDisplay) limitDisplayableLength(); onTextChangedForAutocomplete(); &#125; public void onTextChangedForAutocomplete() &#123; //Ëß¶ÂèëÊêúÁ¥¢Âª∫ËÆÆËé∑ÂèñÁöÑÈÄªËæë &#125; /** * Sets whether text changes should trigger autocomplete. * &lt;p&gt; * enabling autocomplete. * * @param ignoreAutocomplete Whether text changes should be ignored and no auto complete * triggered. */ public void setIgnoreTextChangeFromAutocomplete(boolean ignoreAutocomplete) &#123; mIgnoreTextChangeFromAutocomplete = ignoreAutocomplete; &#125; public void setAutocompleteText(CharSequence userText, CharSequence inlineAutocompleteText) &#123; setAutocompleteTextInternal(userText.toString(), inlineAutocompleteText.toString()); &#125; private void setAutocompleteTextInternal(String userText, String autocompleteText) &#123; mPreviouslySetState.set(userText, autocompleteText, userText.length(), userText.length()); // TODO(changwan): avoid any unnecessary removal and addition of autocomplete text when it // is not changed or when it is appended to the existing autocomplete text. if (mInputConnection != null) &#123; mInputConnection.onBeginImeCommand(); mInputConnection.onEndImeCommand(); &#125; &#125; @Override public InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; //ÂàõÂª∫InputConnection mBatchEditNestCount = 0; mInputConnection = new AutocompleteInputConnection(); mInputConnection.setTarget(super.onCreateInputConnection(outAttrs)); return mInputConnection; &#125; Have Fun :)]]></content>
      <categories>
        <category>ÁßªÂä®ÂºÄÂèë</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Chrome</tag>
        <tag>Gboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18.02ÊÄªÁªì]]></title>
    <url>%2F2018%2F03%2F02%2F18.02%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[‰∫î‰ª∂‰∫ã Ë¢´ÂèñÊï¥ÁöÑÂπ¥ÁªàÂ•ñ Ê≤°Êúâ‰∏≠Â•ñÁöÑÂπ¥‰ºö Â§ßÂπ¥ÂàùÂõõÂõûÂåó‰∫¨ÁöÑÊò•ËäÇ Êôö‰∏äÊê¨ÂÆ∂&amp;‰∏ÄÂ§©Êî∂Êãæ&amp;‰∏âÊåáÂèó‰º§ ÊéâÂÖ¨‰∫§Âç°&amp;ÂºïÂèëÁöÑ‰∏ÄÁ≥ªÂàó‰∫ãÊÉÖ Âè™ËØ¥ÈáçÁÇπ Ë¢´ÂèñÊï¥ÁöÑÂπ¥ÁªàÂ•ñÂΩìÂàùÁäπË±´‰∫Ü‰∏§Âë®Ê≤°ÊúâÊù•ÂÖ¨Âè∏ÔºåÂØºËá¥Âπ¥ÁªàÂ•ñËÆ°ÁÆóÂ∑•‰ΩúÊó∂Èó¥‰∏çË∂≥0.2ÔºåÊåâÁÖß0.1ËÆ°ÁÆó‰∫ÜÔºå‰∏çËøáËá™Â∑±Áé∞Âú®ÂØπÁõÆÂâçÁöÑÂ∑•‰ΩúÂæàÊª°ÊÑè„ÄÇ Ê≤°Êúâ‰∏≠Â•ñÁöÑÂπ¥‰ºöÂπ¥‰ºöÂú∫Âú∞‰∏çÂ§üÂ§ßÔºåÊäΩÁ≠æÂÜ≥ÂÆöËÉΩ‰∏çËÉΩÂéªÔºåÂÖ®Â∞èÁªÑÂè™ÊúâÊàë‰∏Ä‰∏™‰∫∫Ê≤°ÊúâÊäΩ‰∏≠ÔºåÂà∞‰∫ÜÂπ¥‰ºöÈÇ£‰∏ÄÂ§©‰πüÊ≤°‰∏≠‰ªª‰ΩïÂ•ñÔºåËøêÊ∞î‰∏çÂÆàÊÅíÂïä„ÄÇ Â§ßÂπ¥ÂàùÂõõÂõûÂåó‰∫¨ÁöÑÊò•ËäÇËÖäÊúà28‰∏ãÂçàÂõûÂÆ∂ÔºåÂà∞‰∫ÜÈÉëÂ∑ûÁõ¥Êé•Âùê‰∫ÜÂú∞ÈìÅÂéª‰∫ÜÂåªÈô¢ÔºåÊØç‰∫≤ÁóÖ‰∫ÜÔºåÂπ¥Âêé‰∏§‰∏™ÂßêÂßêÈÉΩ‰∏çÂú®ÂÆ∂ÔºåËàÖËàÖÂÆ∂‰πüÂõ†‰∏∫Ë°®Âì•ÁªìÂ©öÂáÜÂ§á‰∏úË•øÔºåÂæàÊó©Â∞±Ëµ∞‰∫ÜÔºå‰ªäÂπ¥ÁöÑÂπ¥ËøáÁöÑÊ†ºÂ§ñÂÜ∑Ê∏Ö„ÄÇ Êôö‰∏äÊê¨ÂÆ∂&amp;‰∏ÄÂ§©Êî∂Êãæ&amp;‰∏âÊåáÂèó‰º§Â§ßÊôö‰∏äÊ≤°ÂêÉÈ•≠Ôºå‰π∞‰∫ÜÂá†‰∏™ÂåÖÂ≠êÔºåÂêÉÂÆåÔºåÊÉ≥ÁùÄ‰∏çËÉΩÊãñÂª∂ÔºåÂ∞±Â§ßÊôö‰∏äÊê¨‰∫ÜÂÆ∂Ôºå‰∏ä‰∏ãÊ•º5Â±ÇÔºå‰∏≠Èó¥ÊÑüËßâË¶ÅÁ¥ØÊ≠ªÔºåË∫´‰Ωì‰∏çË°åÔºåË¶ÅÂä†Âº∫ÈîªÁÇº„ÄÇ ÊéâÂÖ¨‰∫§Âç°&amp;ÂºïÂèëÁöÑ‰∏ÄÁ≥ªÂàó‰∫ãÊÉÖÂéªÊÄªÂèÇÔºåÂùêÂú®Â∫ß‰Ωç‰∏äÔºåËµ∞ÁöÑÊó∂ÂÄôÂÖ¨‰∫§Âç°Êéâ‰∫ÜÂá∫Êù•ÔºåÁ¨¨‰∫åÂ§©Áù°‰∫Ü‰∏™ÊáíËßâÔºå‰∏äÁè≠ÁöÑÊó∂ÂÄôÊâçÂèëÁé∞ÂÖ¨‰∫§Âç°Ê≤°‰∫ÜÔºåÂõûÂÆ∂Êâæ‰πüÊ≤°ÊâæÂà∞ÔºåÊÑüËßâËêΩÂà∞‰∫ÜÊÄªÂèÇÂ∫ß‰ΩçÔºåÂÖàÂéª‰∫ÜÈôÑËøëÁöÑÂú∞ÈìÅÁ´ôÔºåÊÉ≥ÁùÄ‰π∞Âº†Êñ∞Âç°ÔºåÁªìÊûúÈÇ£‰∏™Âú∞ÈìÅÁ´ô‰∏çÂçñÔºåÂèàË∑ëÂõûÂÖ¨‰∫§Á´ôÂùêÂÖ¨‰∫§Ôºå‰∏äËΩ¶‰ª•‰∏∫ÊúâÂîÆÁ•®ÂëòÔºåÁªìÊûúÊ≤°ÊúâÂîÆÁ•®ÂëòÔºåÂ∞±‰∫§‰∫Ü‰∏ÄÂº†Êï¥Èí±ÔºåÊ≤°ÊúâÊâæÈõ∂ÔºåÊúÄÁªàÂú®ÂÖ∂‰ªñÂú∞ÈìÅÁ´ô‰∏ãËΩ¶‰∫ÜÔºå‰π∞‰∫ÜÂº†Êñ∞Âç°ÔºåÂà∞ÂÖ¨Âè∏ËøüÂà∞Ôºå‰πüÊ≤°ÂêÉ‰∏äÊó©È•≠„ÄÇ]]></content>
      <categories>
        <category>ÊÄªÁªì</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HexoÂêåÊó∂ÈÉ®ÁΩ≤codingÂíågithub]]></title>
    <url>%2F2018%2F03%2F02%2FHexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2coding%E5%92%8Cgithub%2F</url>
    <content type="text"><![CDATA[ÈòøÈáå‰∫ëËß£ÊûêÈÖçÁΩÆ ping √ó√ó√ó.coding.meÂíå√ó√ó√ó.github.ioËé∑ÂèñÂà∞ÂõΩÂÜÖcodingÊúçÂä°Âô®ipÂú∞ÂùÄÂíåÂõΩÂ§ñgithubÊúçÂä°Âô®Âú∞ÂùÄ Â∞ÜËøô‰∏§‰∏™ipÊ∑ªÂä†‰∏∫AËÆ∞ÂΩïÔºå‰∏ªÊú∫ËÆ∞ÂΩï‰∏∫wwwÔºåËÆ∞ÂΩïÂÄºÂ°´ÂÜôpingÂá∫Êù•ÁöÑÂú∞ÂùÄÔºåÂ∞ÜcodingÁöÑipËÆæÁΩÆ‰∏∫ÈªòËÆ§ÁöÑÔºåÂ∞ÜgithubÁöÑipËÆæÁΩÆ‰∏∫„Äê‰∏ñÁïå„Äë Ê∑ªÂä†‰∏§‰∏™CNAMEËÆ∞ÂΩïÁ±ªÂûãÔºå‰∏ªÊú∫Á±ªÂûã‰∏∫@ÔºåËß£ÊûêË∑ØÁ∫ø√ó√ó√ó.coding.me „ÄêÊà™ÂõæÂæÖË°•ÂÖÖ„Äë]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
