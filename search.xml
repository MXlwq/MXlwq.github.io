<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bug记录之安卓.9图]]></title>
    <url>%2F2018%2F06%2F19%2FBug%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%AE%89%E5%8D%93-9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[问题现象Popwindow里面写了一个ListView，有个加了圆角阴影.9背景图的LinearLayout做父容器。ListView内容只显示一两个的时候，没有覆盖LinearLayout，流了一部分空白。 分析问题刚开始以为以为是因为自己手动设置了ListView的layoutparams的height值导致的（因为要做一个ListView最多显示5个的需求），后来去掉了这段代码依然没有解决。最终偶然去掉了LinearLayout的.9背景，发现显示的没有问题了，原来是在设置了.9的控件，高度为Wrap Content的时候，LinearLayout的高度以.9背景图的原始不压缩高度来计算，并不会压缩😅]]></content>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio .gitignore修改后不生效的问题]]></title>
    <url>%2F2018%2F06%2F01%2FAndroid-Studio-gitignore%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题Android Studio .gitignore修改后不生效，没有ignore对应的文件， 原因git没有清理cache重点内容 解决方案123git rm -r --cached .git add .git commit -m &apos;Your commit-msg&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android开发者重装Ubuntu需要做的几件事]]></title>
    <url>%2F2018%2F05%2F30%2FAndroid%E5%BC%80%E5%8F%91%E8%80%85%E9%87%8D%E8%A3%85Ubuntu%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E5%87%A0%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[提示文中所有蓝色文字都是可以点击跳转的对应详细地址 更新1sudo apt-get update 安装系统工具Vim1234#安装sudo apt install vim#配置vi ~/.vimrc Git1sudo apt-get install git Python12sudo apt-get install pythonsudo apt-get install python3 JDK1解压即可 安装常用软件Chrome1234wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key addsudo sh -c &apos;echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google-chrome.list&apos;sudo apt-get updatesudo apt-get install google-chrome-stable 搜狗输入法123456789101112131415# 安装fcitx键盘输入法系统sudo add-apt-repository ppa:fcitx-team/nightlysudo apt-get updatesudo apt-get install fcitxsudo apt-get install fcitx-config-gtksudo apt-get install fcitx-table-allsudo apt-get install im-switch # 输入Y# 下载搜狗输入法https://pinyin.sogou.com/linux/?r=pinyinsudo apt-get install -fsudo dpkg -i sogoupinyin_***.deb# 系统默认键盘输入法系统从ibus修改为fcitx# 在安装的Fcitx配置中(如果没有)添加搜狗输入法# Logout当前用户 截图工具Shutter123456# 安装sudo add-apt-repository ppa:shutter/ppasudo apt-get updatesudo apt-get install shutter# 设置快捷键系统设置的键盘设置(详见Shutter对应地址) indicator-sysmonitor123sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor sudo apt-get update sudo apt-get install indicator-sysmonitor 安装IDEAndroid Studio添加Android Studio图标到左侧的工具栏在Android Studio时Configure中选择Create Desktop Entry或者在Android Studio启动后在 Help中的Find Action搜索Create Desktop Entry 配置环境变量修改文件1sudo gedit .bashrc JAVA12345JAVA_HOME=/usr/java/jdk1.8.0_101 #Your Java pathJRE_HOME=$JAVA_HOME/jreJAVA_BIN=$JAVA_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin Android12export ANDROID_HOME=/home/android/Sdkexport PATH=$PATH:$ANDROID_HOME/tools/:$ANDROID_HOME/platform-tools/ 添加快捷命令1234567891011alias upload=&quot;repo upload .&quot;alias pull=&quot;git pull --rebase&quot;alias ba=&quot;git checkout alpha&quot;alias bd=&quot;git checkout dev&quot;alias add=&quot;git add .&quot;alias cm=&quot;git commit -s&quot;alias in=&quot;adb install -r&quot;alias ind=&quot;adb install -r /home/app/Demo/build/outputs/apk/debug.apk&quot;alias inr=&quot;adb install -r /home/app/Demo/build/outputs/apk/release.apk&quot;alias asd=&quot;./gradlew assembledebug&quot;alias asr=&quot;./gradlew assemblerelease&quot;]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 解压文件中文名乱码]]></title>
    <url>%2F2018%2F05%2F04%2FUbuntu-%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E5%90%8D%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Ubuntu 解压文件中文名乱码解决方案123sudo apt-get install unarunar 解压文件名称 Have Fun:)]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Intent定义选择器打开相机和相册]]></title>
    <url>%2F2018%2F04%2F17%2FAndroid-Intent%E5%AE%9A%E4%B9%89%E9%80%89%E6%8B%A9%E5%99%A8%E6%89%93%E5%BC%80%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Android Intent选择打开相机和相册CSDN博客对应文章地址 需求上传图片，点击按钮弹出选择相机拍照或者相册选择照片 解决方案Intent.ACTION_CHOOSER ### 打开相机 12Intent captureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);captureIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); 打开相册12Intent albumIntent = new Intent(Intent.ACTION_PICK, null);albumIntent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;); 使用Intent.ACTION_CHOOSER将相机和相册合在一起123456789101112//创建ChooserIntentIntent intent = new Intent(Intent.ACTION_CHOOSER);//创建相机IntentIntent captureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);captureIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);//将相机Intent以数组形式放入Intent.EXTRA_INITIAL_INTENTSintent.putExtra(Intent.EXTRA_INITIAL_INTENTS, new Intent&#123;captureIntent&#125;);//创建相册IntentIntent albumIntent = new Intent(Intent.ACTION_PICK, null);albumIntent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);//将相册Intent放入Intent.EXTRA_INTENTintent.putExtra(Intent.EXTRA_INTENT, albumIntent); Have Fun:)]]></content>
      <tags>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18.03总结]]></title>
    <url>%2F2018%2F03%2F29%2F18-03%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[三月总结驾校练车，通过科目二三月的四个周末有三个都是在驾校度过的，两个周末学了7个学时的科目二，之前从来没有碰过车，刚开始学的时候，遇到紧急情况老是猛松刹车，就导致熄火，一直以为和游戏里一样，只要松开手，车速就会降低，后来熟悉了，学起来也挺快的。最终顺利通过考试，因为驾校人多，预约的科目三已经到了四月底。 苹果终于能刷公交了在三月的最后两天，苹果推送了iOS11.3正式版的更新，这次更新带来了不少的新Feature，其中我最喜欢的就是可以支持北京和上海刷公交和地铁，虽然我米的手机在15年就可以了，但是对苹果来说，这是国内比较大的本地化吧，实际体验了一下，刚开始因为刷卡方式不对，整个手机贴在刷卡机器上，出现了两次直接扣全程车费的情况，但是看别人说地铁都没问题，最初以为是有些公交车的刷卡机不太兼容，但是又想到安卓手机刷都没有问题，后来在微博上看到了评论说要用手机头部贴在刷卡机器上，三秒左右，或者听到刷卡机器滴声响起，不能像公交卡一样，重复多刷也不会多扣款，然后之后都按照这样来做，果然没有再出站原来的问题。最后附上我的公众号关于iPhone开通公交卡的教程]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment getContext() NoSuchMethodError]]></title>
    <url>%2F2018%2F03%2F26%2FFragment-getContext-NoSuchMethodError%2F</url>
    <content type="text"><![CDATA[Fragment getContext() 在Android低版本（API&lt;=22）中出现NoSuchMethodErrorLog日志12345678910111213Exception java.lang.NoSuchMethodError: No virtual method getContext()Landroid/content/Context; in class Lcom/android/browser/preferences/MainPreferenceFragment; or its super classes (declaration of &apos;com.android.browser.preferences.MainPreferenceFragment&apos; appears in /system/priv-app/Browser/Browser.apk)com.android.browser.preferences.MainPreferenceFragment.onPreferenceChange (SourceFile:203)android.preference.Preference.callChangeListener (Preference.java:928)miui.support.preference.ListPreference.onDialogClosed (SourceFile:300)miui.support.preference.a.onDismiss (SourceFile:130)android.app.Dialog$ListenersHandler.handleMessage (Dialog.java:1263)android.os.Handler.dispatchMessage (Handler.java:102)android.os.Looper.loop (Looper.java:135)android.app.ActivityThread.main (ActivityThread.java:5296)java.lang.reflect.Method.invoke (Method.java)java.lang.reflect.Method.invoke (Method.java:372)com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:912)com.android.internal.os.ZygoteInit.main (ZygoteInit.java:707) 切记Fragment中的getContext()方法是在Android6.0中才出现的，在低于该版本中使用会报NoSuchMethodError，可以使用getActivity()来替换。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu ext硬盘权限修改为当前用户]]></title>
    <url>%2F2018%2F03%2F15%2FUbuntu-ext%E7%A1%AC%E7%9B%98%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[CSDN博客对应文章地址 现象GUI下某个文件夹内无法创建文件夹、删除文件等操作，只能在终端中用sudo 命令来创建和删除文件。 根本原因当前文件所在的组属于root 我的原因Windows+Ubuntu双系统，后来把Windows系统的分区给格式化了，进入Ubuntu修改为ext4格式，出现上述问题。 解决方案12345whoami #查看当前用户名称#在出问题的分区中打开终端，可以看到所在位置和分区的名称sudo chown -R username /media/username/diskname/ #其中的username就是whoami中查出来的，diskname是分区名称sudo umount /media/username/diskname/reboot That’s all, have fun :)]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Hexo搭建需要配置nodejs环境时提示版本过低的方案]]></title>
    <url>%2F2018%2F03%2F15%2FUbuntu-Hexo%E6%90%AD%E5%BB%BA%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AEnodejs%E7%8E%AF%E5%A2%83%E6%97%B6%E6%8F%90%E7%A4%BA%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E7%9A%84%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Ubuntu 配置nodejs环境 使用sudo apt-get install nodejs 直接安装的nodejs版本是4.×版本，和Hexo搭建过程中需要的版本不兼容。可以参考上述地址使用安装npn去更新。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android EditText 通过TextWatcher实现自动补全的注意点]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-EditText-%E9%80%9A%E8%BF%87TextWatcher%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Android EditText 通过TextWatcher实现自动补全的注意点CSDN文章对应地址 背景需求想要实现输入框在用户输入了一定文本的情况下 自动填充一个可能用户想要的结果，类似Chrome手机版的搜索框 实现12345678910111213141516171819202122private class MyWatcher implements TextWatcher &#123; public void afterTextChanged(Editable s) &#123; Log.d(TAG, &quot;doAfterTextChanged..&quot;); if (一些可能防止自动补全的情况) &#123; return; &#125; //为了防止快速输入的情况下重复调用，加一个延时 mHandler.removeMessages(MSG_AUTO_COMPLETE); mHandler.sendEmptyMessageDelayed(MSG_AUTO_COMPLETE, DELAY_AUTO_COMPLETE); &#125; public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; public void onTextChanged(CharSequence s, int start, int before, int count) &#123; //这里可以设置一些标志位，用于防止自动补全，比如这里的识别用户按了删除按键，通过count==0来判断 mLastUrlEditWasDelete = (count == 0); &#125; &#125; 上面一些可能防止自动补全的情况有很多，一般有： 用户点了删除键； 正在处于上一次自动补全的过程中； 存在的兼容性问题功能上线之后，发现国外的用户自动补全后点了删除，会再次自动补全，导致输入框无法删除，这个是很严重的bug，但是在测试和开发的过程中都没有发现，后来发现国外的用户用的是Gboard输入法，默认有一个文本输入建议，而开发和测试都用的国内的输入法，比如讯飞和搜狗等等。这里就出现了输入法的兼容问题，使用不同的输入法，点击删除时回调的TextWatcher的次数不同，在网上找了很多解决方案，最多的就是说让给EditText设置一个输入类型，也就是inputType为textNoSuggestions，还有说用textVisiblePassword的，但是前者textNoSuggestions测试无用，无法控制Gboard不显示输入建议，后者textVisiblePassword会导致只能输入数字和英文，但是海外的用户并不都是输入英文的。所以这些都不是真正的解决方案 或者说不适用于目前的情况。 解决方案在是否自动补全的地方下功夫，判断处于输入法的建议补全的时候就不自动补全123456private boolean shouldAutoComplete() &#123; Editable text = getText(); return !isHandlingBatchInput() &amp;&amp; BaseInputConnection.getComposingSpanEnd(text) == BaseInputConnection.getComposingSpanStart(text);&#125; 缺憾，这样的话，只有用户点击了输入法内的搜索建议的词，输入内容才会出现在EditText中，但是此时不会执行自动补全操作，我的解决方案是使用自定义的InputConnectionWrapper重写EditText的onCreateInputConnection方法， 123456789101112@Overridepublic InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; mInputConnectionWrapper.setTarget(super.onCreateInputConnection(outAttrs)); return InputConnectionWrapper;&#125;InputConnectionWrapper mInputConnectionWrapper = new InputConnectionWrapper(null, true) &#123; @Override public boolean finishComposingText() &#123; autoComplete(mLastSuggestion); return super.finishComposingText(); &#125;&#125;; 在finishComposingText的时候调用一次自己写的autoComplete方法。 Have Fun~]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TextWatcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式备忘和理解——1.分类]]></title>
    <url>%2F2018%2F03%2F09%2F23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%87%E5%BF%98%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[设计模式分类创建型-5种 单例模式 建造者模式 原型模式 工厂方法模式 抽象工厂模式结构型-7种 适配器模式 装饰者模式 结合模式 桥接模式 外观模式 享元模式 代理模式行为型-11种 策略模式 观察者模式 迭代器模式 命令模式模式 备忘录模式 中介者模式 解释器模式 访问者模式 责任链模式 状态模式 模板方法模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View焦点获取]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid%20View%E7%84%A6%E7%82%B9%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[需求来源测试给提了一个bug，发现是焦点转移导致的，想看看是从哪到哪儿转移了。 方案为了定时输出当前获取焦点的控件信息，可以新开一个线程，每n秒调用一下rootview的findFocus 具体如下123456789101112131415new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; View rootview = BrowserActivity.this.getWindow().getDecorView(); View focusView = rootview.findFocus(); Log.i(&quot;LWQ&quot;, focusView == null ? &quot;当前无焦点&quot; : focusView.toString()); &#125; &#125;&#125;).start();]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu状态栏和侧边栏消失解决方案——删除iBus引起]]></title>
    <url>%2F2018%2F03%2F09%2FUbuntu%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4iBus%E5%BC%95%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[Ubuntu删除iBus后状态栏和侧边栏消失解决方案CSDN文章对应地址 起因看到网上的优化教程说用了fctix就不用iBus了，于是就卸载了iBus，没想要的是因为有很多其他的软件会有依赖，比如和界面现实有关系的Unity。 解决方案终端下输入 123dconf reset -f /org/compiz #重置compizsudo apt install unity #如果unity被卸载了，重装unitysetsid unity #重启uni]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome for Android AutoComplete地址栏地址自动补全功能调研和更新]]></title>
    <url>%2F2018%2F03%2F09%2FChrome-for-Android-AutoComplete%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD%E8%B0%83%E7%A0%94%E5%92%8C%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[Chrome地址栏地址自动补全功能调研和更新CSDN文章对应地址 Chrome地址栏地址自动补全功能预览补全前提： 使用Gboard输入法 Gboard输入法打开了【文字更正】功能里面的现实建议栏补全逻辑： 输入一个字符后，将推荐的第一个链接补全，补全的文字为蓝色背景选中状态，并且用户自己输入的文本下面有下划线（这个下划线不是自己通过SpannableString来实现的，应该是EditText自己为待用户选择推荐（commitText）的的文本默认添加的） 输入一个非字母类型的，会自动commitText，但是此时把非字母类型的字符删除后，输入法的输入建议会再次出现，并且之前的用户输入文本会再次出现下划线，这种状态其实就是带选择状态，可以通过输入法最顶部的推荐直接替换文字。 选择了输入法的输入建议文本，浏览器也能继续进行输入推荐和自动补全 最初版本情况Chrome之前的版本其实不是这样的，而是类似于禁用了输入法的输入建议，而直接替换输入框的文本，再将一部分文字设置为select状态。代码实现参考，Android EditText 通过TextWatcher实现自动补全的注意点 Chrome最新版代码实现效果 实现代码主要核心代码，忽略了一些变量的定义，详细参考Chrome源码即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765public void onAutoComplete(String suggestion) &#123; String userText = getTextWithoutAutocomplete(); suggestion = suggestion.startsWith(userText) ? suggestion.replaceFirst(userText, &quot;&quot;) : &quot;&quot;; if (shouldAutocomplete()) &#123; setAutocompleteText(userText, suggestion); &#125; &#125; private void limitDisplayableLength() &#123; // To limit displayable length we replace middle portion of the string with ellipsis. // That affects only presentation of the text, and doesn&apos;t affect other aspects like // copying to the clipboard, getting text with getText(), etc. final int maxLength = MAX_DISPLAYABLE_LENGTH_END; Editable text = getText(); int textLength = text.length(); if (textLength &lt;= maxLength) &#123; if (mDidEllipsizeTextHint) &#123; EllipsisSpan[] spans = text.getSpans(0, textLength, EllipsisSpan.class); if (spans != null &amp;&amp; spans.length &gt; 0) &#123; assert spans.length == 1 : &quot;Should never apply more than a single EllipsisSpan&quot;; for (int i = 0; i &lt; spans.length; i++) &#123; text.removeSpan(spans[i]); &#125; &#125; &#125; mDidEllipsizeTextHint = false; return; &#125; mDidEllipsizeTextHint = true; int spanLeft = text.nextSpanTransition(0, textLength, EllipsisSpan.class); if (spanLeft != textLength) return; spanLeft = maxLength / 2; text.setSpan(EllipsisSpan.INSTANCE, spanLeft, textLength - spanLeft, Editable.SPAN_INCLUSIVE_EXCLUSIVE); &#125; public boolean shouldAutocomplete() &#123; boolean retVal = mBatchEditNestCount == 0 &amp;&amp; mLastEditWasTyping &amp;&amp; mCurrentState.isCursorAtEndOfUserText() &amp;&amp; !isKeyboardBlacklisted() &amp;&amp; isNonCompositionalText(getTextWithoutAutocomplete()); Log.i(TAG, &quot;shouldAutocomplete: &quot; + retVal); return retVal; &#125; private boolean isKeyboardBlacklisted() &#123; String pkgName = getKeyboardPackageName(); return pkgName.contains(&quot;.iqqi&quot;) // crbug.com/767016 || pkgName.contains(&quot;omronsoft&quot;) || pkgName.contains(&quot;.iwnn&quot;); // crbug.com/758443 &#125; public String getKeyboardPackageName() &#123; String defaultIme = Settings.Secure.getString( getContext().getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD); return defaultIme == null ? &quot;&quot; : defaultIme; &#125; public static boolean isNonCompositionalText(String text) &#123; // To start with, we are only activating this for English alphabets, European characters, // numbers and URLs to avoid potential bad interactions with more complex IMEs. // The rationale for including character sets with diacritical marks is that backspacing on // a letter with a diacritical mark most likely deletes the whole character instead of // removing the diacritical mark. // TODO(changwan): also scan for other traditionally non-IME charsets. return NON_COMPOSITIONAL_TEXT_PATTERN.matcher(text).matches(); &#125; @Override protected void onSelectionChanged(int selStart, int selEnd) &#123; if (mCurrentState == null) &#123; return; &#125; if (mCurrentState.getSelStart() == selStart &amp;&amp; mCurrentState.getSelEnd() == selEnd) return; mCurrentState.setSelection(selStart, selEnd); if (mBatchEditNestCount &gt; 0) return; int len = mCurrentState.getUserText().length(); if (mCurrentState.hasAutocompleteText()) &#123; if (selStart &gt; len || selEnd &gt; len) &#123; Log.i(TAG, &quot;Autocomplete text is being touched. Make it real.&quot;); if (mInputConnection != null) mInputConnection.commitAutocomplete(); &#125; else &#123; Log.i(TAG, &quot;Touching before the cursor removes autocomplete.&quot;); clearAutocompleteTextAndUpdateSpanCursor(); &#125; &#125; notifyAutocompleteTextStateChanged(); &#125; private void clearAutocompleteTextAndUpdateSpanCursor() &#123; Log.i(TAG, &quot;clearAutocompleteAndUpdateSpanCursor&quot;); clearAutocompleteText(); // Take effect and notify if not already in a batch edit. if (mInputConnection != null) &#123; mInputConnection.onBeginImeCommand(); mInputConnection.onEndImeCommand(); &#125; else &#123; mSpanCursorController.removeSpan(); notifyAutocompleteTextStateChanged(); &#125; &#125;class AutocompleteState &#123; private String mUserText; private String mAutocompleteText; private int mSelStart; private int mSelEnd; public AutocompleteState(AutocompleteState a) &#123; copyFrom(a); &#125; public AutocompleteState(String userText, String autocompleteText, int selStart, int selEnd) &#123; set(userText, autocompleteText, selStart, selEnd); &#125; public void set(String userText, String autocompleteText, int selStart, int selEnd) &#123; mUserText = userText; mAutocompleteText = autocompleteText; mSelStart = selStart; mSelEnd = selEnd; &#125; public void copyFrom(AutocompleteState a) &#123; set(a.mUserText, a.mAutocompleteText, a.mSelStart, a.mSelEnd); &#125; public String getUserText() &#123; return mUserText; &#125; public String getAutocompleteText() &#123; return mAutocompleteText; &#125; public boolean hasAutocompleteText() &#123; return !TextUtils.isEmpty(mAutocompleteText); &#125; /** @return The whole text including autocomplete text. */ public String getText() &#123; return mUserText + mAutocompleteText; &#125; public int getSelStart() &#123; return mSelStart; &#125; public int getSelEnd() &#123; return mSelEnd; &#125; public void setSelection(int selStart, int selEnd) &#123; mSelStart = selStart; mSelEnd = selEnd; &#125; public void setUserText(String userText) &#123; mUserText = userText; &#125; public void setAutocompleteText(String autocompleteText) &#123; mAutocompleteText = autocompleteText; &#125; public void clearAutocompleteText() &#123; mAutocompleteText = &quot;&quot;; &#125; public boolean isCursorAtEndOfUserText() &#123; return mSelStart == mUserText.length() &amp;&amp; mSelEnd == mUserText.length(); &#125; public boolean isWholeUserTextSelected() &#123; return mSelStart == 0 &amp;&amp; mSelEnd == mUserText.length(); &#125; /** * @param prevState The previous state to compare the current state with. * @return Whether the current state is backward-deleted from prevState. */ public boolean isBackwardDeletedFrom(AutocompleteState prevState) &#123; return isCursorAtEndOfUserText() &amp;&amp; prevState.isCursorAtEndOfUserText() &amp;&amp; isPrefix(mUserText, prevState.mUserText); &#125; /** * @param prevState The previous state to compare the current state with. * @return Whether the current state is forward-typed from prevState. */ public boolean isForwardTypedFrom(AutocompleteState prevState) &#123; return isCursorAtEndOfUserText() &amp;&amp; prevState.isCursorAtEndOfUserText() &amp;&amp; isPrefix(prevState.mUserText, mUserText); &#125; /** * @param prevState The previous state to compare the current state with. * @return The differential string that has been backward deleted. */ public String getBackwardDeletedTextFrom(AutocompleteState prevState) &#123; if (!isBackwardDeletedFrom(prevState)) return null; return prevState.mUserText.substring(mUserText.length()); &#125; public boolean isPrefix(String a, String b) &#123; return b.startsWith(a) &amp;&amp; b.length() &gt; a.length(); &#125; /** * When the user manually types the next character that was already suggested in the previous * autocomplete, then the suggestion is still valid if we simply remove one character from the * beginning of it. For example, if prev = &quot;a[bc]&quot; and current text is &quot;ab&quot;, this method * constructs &quot;ab[c]&quot;. * @param prevState The previous state. * @return Whether the shifting was successful. */ public boolean reuseAutocompleteTextIfPrefixExtension(AutocompleteState prevState) &#123; // Shift when user text has grown or remains the same, but still prefix of prevState&apos;s whole // text. int diff = mUserText.length() - prevState.mUserText.length(); if (diff &lt; 0) return false; if (!isPrefix(mUserText, prevState.getText())) return false; mAutocompleteText = prevState.mAutocompleteText.substring(diff); return true; &#125; public void commitAutocompleteText() &#123; mUserText += mAutocompleteText; mAutocompleteText = &quot;&quot;; &#125; @Override public boolean equals(Object o) &#123; if (!(o instanceof AutocompleteState)) return false; if (o == this) return true; AutocompleteState a = (AutocompleteState) o; return mUserText.equals(a.mUserText) &amp;&amp; mAutocompleteText.equals(a.mAutocompleteText) &amp;&amp; mSelStart == a.mSelStart &amp;&amp; mSelEnd == a.mSelEnd; &#125; @Override public int hashCode() &#123; return mUserText.hashCode() * 2 + mAutocompleteText.hashCode() * 3 + mSelStart * 5 + mSelEnd * 7; &#125; @Override public String toString() &#123; return String.format(Locale.US, &quot;AutocompleteState &#123;[%s][%s] [%d-%d]&#125;&quot;, mUserText, mAutocompleteText, mSelStart, mSelEnd); &#125; &#125; public boolean hasAutocomplete() &#123; boolean retVal = mCurrentState.hasAutocompleteText(); Log.i(TAG, &quot;hasAutocomplete: &quot; + retVal); return retVal; &#125; private class AutocompleteInputConnection extends InputConnectionWrapper &#123; private final AutocompleteState mPreBatchEditState; public AutocompleteInputConnection() &#123; super(null, true); mPreBatchEditState = new AutocompleteState(mCurrentState); &#125; private boolean incrementBatchEditCount() &#123; ++mBatchEditNestCount; // After the outermost super.beginBatchEdit(), EditText will stop selection change // update to the IME app. return super.beginBatchEdit(); &#125; private boolean decrementBatchEditCount() &#123; --mBatchEditNestCount; return super.endBatchEdit(); &#125; public void commitAutocomplete() &#123; Log.i(TAG, &quot;commitAutocomplete&quot;); if (!hasAutocomplete()) return; mCurrentState.commitAutocompleteText(); // Invalidate mPreviouslySetState. mPreviouslySetState.copyFrom(mCurrentState); mLastEditWasTyping = false; incrementBatchEditCount(); // avoids additional notifyAutocompleteTextStateChanged() mSpanCursorController.commitSpan(); decrementBatchEditCount(); &#125; @Override public boolean beginBatchEdit() &#123; Log.i(TAG, &quot;beginBatchEdit&quot;); onBeginImeCommand(); boolean retVal = incrementBatchEditCount(); onEndImeCommand(); return retVal; &#125; /** * Always call this at the beginning of any IME command. Compare this with beginBatchEdit() * which is by itself an IME command. * @return Whether the call was successful. */ public boolean onBeginImeCommand() &#123; Log.i(TAG, &quot;onBeginImeCommand: &quot; + mBatchEditNestCount); boolean retVal = incrementBatchEditCount(); if (mBatchEditNestCount == 1) &#123; mPreBatchEditState.copyFrom(mCurrentState); &#125; else if (mDeletePostfixOnNextBeginImeCommand &gt; 0) &#123; int len = getText().length(); getText().delete(len - mDeletePostfixOnNextBeginImeCommand, len); &#125; mDeletePostfixOnNextBeginImeCommand = 0; mSpanCursorController.removeSpan(); return retVal; &#125; private void restoreBackspacedText(String diff) &#123; Log.i(TAG, &quot;restoreBackspacedText. diff: &quot; + diff); if (mBatchEditNestCount &gt; 0) &#123; // If batch edit hasn&apos;t finished, we will restore backspaced text only for visual // effects. However, for internal operations to work correctly, we need to remove // the restored diff at the beginning of next IME operation. mDeletePostfixOnNextBeginImeCommand = diff.length(); &#125; if (mBatchEditNestCount == 0) &#123; // only at the outermost batch edit if (shouldFinishCompositionOnDeletion()) super.finishComposingText(); &#125; incrementBatchEditCount(); // avoids additional notifyAutocompleteTextStateChanged() Editable editable = getEditableText(); editable.append(diff); decrementBatchEditCount(); &#125; private boolean setAutocompleteSpan() &#123; mSpanCursorController.removeSpan(); if (!mCurrentState.isCursorAtEndOfUserText()) return false; if (mCurrentState.reuseAutocompleteTextIfPrefixExtension(mPreviouslySetState)) &#123; mSpanCursorController.setSpan(mCurrentState); return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean endBatchEdit() &#123; Log.i(TAG, &quot;endBatchEdit&quot;); onBeginImeCommand(); boolean retVal = decrementBatchEditCount(); onEndImeCommand(); return retVal; &#125; /** * Always call this at the end of an IME command. Compare this with endBatchEdit() * which is by itself an IME command. * @return Whether the call was successful. */ public boolean onEndImeCommand() &#123; Log.i(TAG, &quot;onEndImeCommand: &quot; + (mBatchEditNestCount - 1)); String diff = mCurrentState.getBackwardDeletedTextFrom(mPreBatchEditState); if (diff != null) &#123; // Update selection first such that keyboard app gets what it expects. boolean retVal = decrementBatchEditCount(); if (mPreBatchEditState.hasAutocompleteText()) &#123; // Undo delete to retain the last character and only remove autocomplete text. restoreBackspacedText(diff); &#125; mLastEditWasTyping = false; clearAutocompleteText(); notifyAutocompleteTextStateChanged(); return retVal; &#125; if (!setAutocompleteSpan()) &#123; clearAutocompleteText(); &#125; boolean retVal = decrementBatchEditCount(); // Simply typed some characters or whole text selection has been overridden. if (mCurrentState.isForwardTypedFrom(mPreBatchEditState) || (mPreBatchEditState.isWholeUserTextSelected() &amp;&amp; mCurrentState.getUserText().length() &gt; 0 &amp;&amp; mCurrentState.isCursorAtEndOfUserText())) &#123; mLastEditWasTyping = true; &#125; notifyAutocompleteTextStateChanged(); return retVal; &#125; @Override public boolean commitText(CharSequence text, int newCursorPosition) &#123; Log.i(TAG, &quot;commitText: &quot; + text); onBeginImeCommand(); boolean retVal = super.commitText(text, newCursorPosition); onEndImeCommand(); return retVal; &#125; @Override public boolean setComposingText(CharSequence text, int newCursorPosition) &#123; Log.i(TAG, &quot;setComposingText: &quot; + text); onBeginImeCommand(); boolean retVal = super.setComposingText(text, newCursorPosition); onEndImeCommand(); return retVal; &#125; @Override public boolean setComposingRegion(int start, int end) &#123; onBeginImeCommand(); boolean retVal = super.setComposingRegion(start, end); onEndImeCommand(); return retVal; &#125; @Override public boolean finishComposingText() &#123; Log.i(TAG, &quot;finishComposingText&quot;); onBeginImeCommand(); boolean retVal = super.finishComposingText(); onEndImeCommand(); return retVal; &#125; @Override public boolean deleteSurroundingText(final int beforeLength, final int afterLength) &#123; onBeginImeCommand(); boolean retVal = super.deleteSurroundingText(beforeLength, afterLength); onEndImeCommand(); return retVal; &#125; @Override public boolean setSelection(final int start, final int end) &#123; onBeginImeCommand(); boolean retVal = super.setSelection(start, end); onEndImeCommand(); return retVal; &#125; @Override public boolean performEditorAction(final int editorAction) &#123; Log.i(TAG, &quot;performEditorAction: &quot; + editorAction); onBeginImeCommand(); commitAutocomplete(); boolean retVal = super.performEditorAction(editorAction); onEndImeCommand(); return retVal; &#125; @Override public boolean sendKeyEvent(final KeyEvent event) &#123; Log.i(TAG, &quot;sendKeyEvent: &quot; + event.getKeyCode()); onBeginImeCommand(); boolean retVal = super.sendKeyEvent(event); onEndImeCommand(); return retVal; &#125; @Override public ExtractedText getExtractedText(final ExtractedTextRequest request, final int flags) &#123; Log.i(TAG, &quot;getExtractedText&quot;); onBeginImeCommand(); ExtractedText retVal = super.getExtractedText(request, flags); onEndImeCommand(); return retVal; &#125; @Override public CharSequence getTextAfterCursor(final int n, final int flags) &#123; Log.i(TAG, &quot;getTextAfterCursor&quot;); onBeginImeCommand(); CharSequence retVal = super.getTextAfterCursor(n, flags); onEndImeCommand(); return retVal; &#125; @Override public CharSequence getTextBeforeCursor(final int n, final int flags) &#123; Log.i(TAG, &quot;getTextBeforeCursor&quot;); onBeginImeCommand(); CharSequence retVal = super.getTextBeforeCursor(n, flags); onEndImeCommand(); return retVal; &#125; @Override public CharSequence getSelectedText(final int flags) &#123; Log.i(TAG, &quot;getSelectedText&quot;); onBeginImeCommand(); CharSequence retVal = super.getSelectedText(flags); onEndImeCommand(); return retVal; &#125; @Override public boolean commitCompletion(CompletionInfo text) &#123; Log.i(TAG, &quot;commitCompletion&quot;); onBeginImeCommand(); boolean retVal = super.commitCompletion(text); onEndImeCommand(); return retVal; &#125; @Override public boolean commitContent(InputContentInfo inputContentInfo, int flags, Bundle opts) &#123; Log.i(TAG, &quot;commitContent&quot;); onBeginImeCommand(); boolean retVal = super.commitContent(inputContentInfo, flags, opts); onEndImeCommand(); return retVal; &#125; @Override public boolean commitCorrection(CorrectionInfo correctionInfo) &#123; Log.i(TAG, &quot;commitCorrection&quot;); onBeginImeCommand(); boolean retVal = super.commitCorrection(correctionInfo); onEndImeCommand(); return retVal; &#125; @Override public boolean deleteSurroundingTextInCodePoints(int beforeLength, int afterLength) &#123; Log.i(TAG, &quot;deleteSurroundingTextInCodePoints&quot;); onBeginImeCommand(); boolean retVal = super.deleteSurroundingTextInCodePoints(beforeLength, afterLength); onEndImeCommand(); return retVal; &#125; @Override public int getCursorCapsMode(int reqModes) &#123; Log.i(TAG, &quot;getCursorCapsMode&quot;); onBeginImeCommand(); int retVal = super.getCursorCapsMode(reqModes); onEndImeCommand(); return retVal; &#125; @Override public boolean requestCursorUpdates(int cursorUpdateMode) &#123; Log.i(TAG, &quot;requestCursorUpdates&quot;); onBeginImeCommand(); boolean retVal = super.requestCursorUpdates(cursorUpdateMode); onEndImeCommand(); return retVal; &#125; @Override public boolean clearMetaKeyStates(int states) &#123; Log.i(TAG, &quot;clearMetaKeyStates&quot;); onBeginImeCommand(); boolean retVal = super.clearMetaKeyStates(states); onEndImeCommand(); return retVal; &#125; &#125; private boolean shouldFinishCompositionOnDeletion() &#123; String defaultIme = Settings.Secure.getString( getContext().getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD); defaultIme = defaultIme == null ? &quot;&quot; : defaultIme; return !defaultIme.contains(&quot;com.sec.android.inputmethod&quot;); &#125; private int mDeletePostfixOnNextBeginImeCommand; private void clearAutocompleteText() &#123; Log.i(TAG, &quot;clearAutocomplete&quot;); mPreviouslySetState.clearAutocompleteText(); mCurrentState.clearAutocompleteText(); &#125; private final AutocompleteState mPreviouslyNotifiedState; private void notifyAutocompleteTextStateChanged() &#123; if (mBatchEditNestCount &gt; 0) &#123; // crbug.com/764749 Log.w(TAG, &quot;Did not notify - in batch edit.&quot;); return; &#125; if (mCurrentState.equals(mPreviouslyNotifiedState)) &#123; // crbug.com/764749 Log.w(TAG, &quot;Did not notify - no change.&quot;); return; &#125; if (mCurrentState.getUserText().equals(mPreviouslyNotifiedState.getUserText()) &amp;&amp; (mCurrentState.hasAutocompleteText() || !mPreviouslyNotifiedState.hasAutocompleteText())) &#123; // Nothing has changed except that autocomplete text has been set or modified. Or // selection change did not affect autocomplete text. Autocomplete text is set by the // controller, so only text change or deletion of autocomplete text should be notified. mPreviouslyNotifiedState.copyFrom(mCurrentState); return; &#125; mPreviouslyNotifiedState.copyFrom(mCurrentState); if (mIgnoreTextChangeFromAutocomplete) &#123; // crbug.com/764749 Log.w(TAG, &quot;Did not notify - ignored.&quot;); return; &#125; // The current model&apos;s mechanism always moves the cursor at the end of user text, so we // don&apos;t need to update the display. onAutocompleteTextStateChanged(false /* updateDisplay */); &#125; private static class SpanCursorController &#123; private final PopUpWindowInAutoCompleteTextView mDelegate; private BackgroundColorSpan mSpan; public SpanCursorController(PopUpWindowInAutoCompleteTextView delegate) &#123; mDelegate = delegate; &#125; public void setSpan(AutocompleteState state) &#123; int sel = state.getSelStart(); if (mSpan == null) mSpan = new BackgroundColorSpan(mDelegate.getHighlightColor()); SpannableString spanString = new SpannableString(state.getAutocompleteText()); // The flag here helps make sure that span does not get spill to other part of the text. spanString.setSpan(mSpan, 0, state.getAutocompleteText().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Editable editable = mDelegate.getEditableText(); editable.append(spanString); // Keep the original selection before adding spannable string. Selection.setSelection(editable, sel, sel); setCursorVisible(false); Log.i(TAG, &quot;setSpan: &quot; + getEditableDebugString(editable)); &#125; private void setCursorVisible(boolean visible) &#123; if (mDelegate.isFocused()) mDelegate.setCursorVisible(visible); &#125; private int getSpanIndex(Editable editable) &#123; if (editable == null || mSpan == null) return -1; return editable.getSpanStart(mSpan); // returns -1 if mSpan is not attached &#125; public void reset() &#123; setCursorVisible(true); Editable editable = mDelegate.getEditableText(); int idx = getSpanIndex(editable); if (idx != -1) &#123; editable.removeSpan(mSpan); &#125; mSpan = null; &#125; public boolean removeSpan() &#123; setCursorVisible(true); Editable editable = mDelegate.getEditableText(); int idx = getSpanIndex(editable); if (idx == -1) return false; editable.removeSpan(mSpan); editable.delete(idx, editable.length()); mSpan = null; &#123; Log.i(TAG, &quot;removeSpan - after removal: &quot; + getEditableDebugString(editable)); &#125; return true; &#125; public void commitSpan() &#123; mDelegate.getEditableText().removeSpan(mSpan); setCursorVisible(true); &#125; public void reflectTextUpdateInState(AutocompleteState state, CharSequence text) &#123; if (text instanceof Editable) &#123; Editable editable = (Editable) text; int idx = getSpanIndex(editable); if (idx != -1) &#123; // We do not set autocomplete text here as model should solely control it. state.setUserText(editable.subSequence(0, idx).toString()); return; &#125; &#125; state.setUserText(text.toString()); &#125; &#125; /** * @param editable The editable. * @return Debug string for the given &#123;@Editable&#125;. */ private static String getEditableDebugString(Editable editable) &#123; return String.format(Locale.US, &quot;Editable &#123;[%s] SEL[%d %d] COM[%d %d]&#125;&quot;, editable.toString(), Selection.getSelectionStart(editable), Selection.getSelectionEnd(editable), BaseInputConnection.getComposingSpanStart(editable), BaseInputConnection.getComposingSpanEnd(editable)); &#125; @Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; Log.i(TAG, &quot;onTextChanged: &quot; + text); if(mSpanCursorController==null)&#123; return; &#125; mSpanCursorController.reflectTextUpdateInState(mCurrentState, text); if (mBatchEditNestCount &gt; 0) return; // let endBatchEdit() handles changes from IME. // An external change such as text paste occurred. mLastEditWasTyping = false; clearAutocompleteTextAndUpdateSpanCursor(); &#125; public String getTextWithoutAutocomplete() &#123; String retVal = mCurrentState.getUserText(); Log.i(TAG, &quot;getTextWithoutAutocomplete: &quot; + retVal); return retVal; &#125; public void onAutocompleteTextStateChanged(boolean updateDisplay) &#123; if (updateDisplay) limitDisplayableLength(); onTextChangedForAutocomplete(); &#125; public void onTextChangedForAutocomplete() &#123; //触发搜索建议获取的逻辑 &#125; /** * Sets whether text changes should trigger autocomplete. * &lt;p&gt; * enabling autocomplete. * * @param ignoreAutocomplete Whether text changes should be ignored and no auto complete * triggered. */ public void setIgnoreTextChangeFromAutocomplete(boolean ignoreAutocomplete) &#123; mIgnoreTextChangeFromAutocomplete = ignoreAutocomplete; &#125; public void setAutocompleteText(CharSequence userText, CharSequence inlineAutocompleteText) &#123; setAutocompleteTextInternal(userText.toString(), inlineAutocompleteText.toString()); &#125; private void setAutocompleteTextInternal(String userText, String autocompleteText) &#123; mPreviouslySetState.set(userText, autocompleteText, userText.length(), userText.length()); // TODO(changwan): avoid any unnecessary removal and addition of autocomplete text when it // is not changed or when it is appended to the existing autocomplete text. if (mInputConnection != null) &#123; mInputConnection.onBeginImeCommand(); mInputConnection.onEndImeCommand(); &#125; &#125; @Override public InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; //创建InputConnection mBatchEditNestCount = 0; mInputConnection = new AutocompleteInputConnection(); mInputConnection.setTarget(super.onCreateInputConnection(outAttrs)); return mInputConnection; &#125; Have Fun :)]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Chrome</tag>
        <tag>Gboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18.02总结]]></title>
    <url>%2F2018%2F03%2F02%2F18.02%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[五件事 被取整的年终奖 没有中奖的年会 大年初四回北京的春节 晚上搬家&amp;一天收拾&amp;三指受伤 掉公交卡&amp;引发的一系列事情 只说重点 被取整的年终奖当初犹豫了两周没有来公司，导致年终奖计算工作时间不足0.2，按照0.1计算了，不过自己现在对目前的工作很满意。 没有中奖的年会年会场地不够大，抽签决定能不能去，全小组只有我一个人没有抽中，到了年会那一天也没中任何奖，运气不守恒啊。 大年初四回北京的春节腊月28下午回家，到了郑州直接坐了地铁去了医院，母亲病了，年后两个姐姐都不在家，舅舅家也因为表哥结婚准备东西，很早就走了，今年的年过的格外冷清。 晚上搬家&amp;一天收拾&amp;三指受伤大晚上没吃饭，买了几个包子，吃完，想着不能拖延，就大晚上搬了家，上下楼5层，中间感觉要累死，身体不行，要加强锻炼。 掉公交卡&amp;引发的一系列事情去总参，坐在座位上，走的时候公交卡掉了出来，第二天睡了个懒觉，上班的时候才发现公交卡没了，回家找也没找到，感觉落到了总参座位，先去了附近的地铁站，想着买张新卡，结果那个地铁站不卖，又跑回公交站坐公交，上车以为有售票员，结果没有售票员，就交了一张整钱，没有找零，最终在其他地铁站下车了，买了张新卡，到公司迟到，也没吃上早饭。]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo同时部署coding和github]]></title>
    <url>%2F2018%2F03%2F02%2FHexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2coding%E5%92%8Cgithub%2F</url>
    <content type="text"><![CDATA[阿里云解析配置 ping ×××.coding.me和×××.github.io获取到国内coding服务器ip地址和国外github服务器地址 将这两个ip添加为A记录，主机记录为www，记录值填写ping出来的地址，将coding的ip设置为默认的，将github的ip设置为【世界】 添加两个CNAME记录类型，主机类型为@，解析路线×××.coding.me 【截图待补充】]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
